<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lefo的菜鸡实录</title>
  <icon>https://www.gravatar.com/avatar/480d7d5ef5660a0927e82173742c59a2</icon>
  <subtitle>又是一个android开发</subtitle>
  <link href="https://lefo.me/atom.xml" rel="self"/>
  
  <link href="https://lefo.me/"/>
  <updated>2025-10-24T04:45:37.609Z</updated>
  <id>https://lefo.me/</id>
  
  <author>
    <name>lefo</name>
    <email>lefo#lefo.me(#换成@你懂得)</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>android打包固定id</title>
    <link href="https://lefo.me/2025/10/24/public-ids/"/>
    <id>https://lefo.me/2025/10/24/public-ids/</id>
    <published>2025-10-24T03:11:27.000Z</published>
    <updated>2025-10-24T04:45:37.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>6月份跳槽来了一家广告公司，整个业务逻辑就是流量玩法，上架市场，买量，赚广告费。因为gp上架越来越难，就衍生出一种玩法叫AB面。关于AB面，这里先不讲，主要说说B包的资源处理。这篇没技术，单纯自己记下来当笔记用。</p><h1 id="id"><a href="#id" class="headerlink" title="id"></a>id</h1><p>id其实是个整数，应用内的id一般情况是<code>0x7fxxxxxx</code>，这个hex其实是<code>package</code>,<code>type</code>,<code>value</code>的结构。而代码中如果有R.id.xx，会在编译时直接替换成该整数。做AB面的包，B包都是通过动态加载的，这就导致这个整数，必须在使用时，和你的资源对应。10年有，有种粗暴的解决办法，就是构建一个自己的aapt，可以指定<code>package</code>，也就是前面的<code>7f</code>，然后再用添加Resources的方式，将资源添加到资源管理器中。这样就能一劳永逸。B包打包，使用0x7e的资源，A包不处理，这样AB的资源就不会冲突。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">android&#123;</span><br><span class="line">    aaptOptions &#123;</span><br><span class="line">        additionalParameters <span class="string">&quot;--package-id&quot;</span>, <span class="string">&quot;0x7E&quot;</span>, <span class="string">&quot;--allow-reserved-package-id&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h1 id="固定id"><a href="#固定id" class="headerlink" title="固定id"></a>固定id</h1><p>上述方法是打包了两套resource，缺点就是需要将自己的Resources添加到系统Resources，如果资源少，又想尽量避免动态加载资源，直接指定需要指定的资源id就行。而aapt恰好就提供了一个参数<code>--stable-ids</code>。</p><ol><li>在A包中对应资源位置添加B包的资源，构建B包</li><li>在build&#x2F;intermediates&#x2F;stable_resource_ids_file&#x2F;release&#x2F;processReleaseResources&#x2F;stableIds.txt，能找到B包的资源，复制你想要固定的id。</li><li>将复制出来的内容，加到app&#x2F;public.txt</li><li>gradle添加如下，然后build。<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">android&#123;</span><br><span class="line">    aaptOptions &#123;</span><br><span class="line">        <span class="comment">// 注意路径</span></span><br><span class="line">        File publicTxtFile = project.file(<span class="string">&#x27;public.txt&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> (publicTxtFile.exists()) &#123;</span><br><span class="line">            project.logger.error <span class="string">&quot;$&#123;publicTxtFile&#125; exists, apply it.&quot;</span></span><br><span class="line">            <span class="comment">//-stable-ids</span></span><br><span class="line">            aaptOptions.additionalParameters(<span class="string">&quot;--stable-ids&quot;</span>, <span class="string">&quot;$&#123;publicTxtFile&#125;&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            project.logger.error <span class="string">&quot;$&#123;publicTxtFile&#125; not exists&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>构建完成不放心可以Analyze APK看一看</li></ol><h1 id="其它方案"><a href="#其它方案" class="headerlink" title="其它方案"></a>其它方案</h1><ol><li>自定义aapt、dex字节修改，市面上有一些开源工具。</li><li>转换调用。11年的时候，做过一款sdk，当时采用的是提供了一个工具类，包含一堆getxxxID函数。然后，所有调用资源全使用get函数调用不打入jar包(可以理解为B包)，工具类提供给商户(A包)。</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;6月份跳槽来了一家广告公司，整个业务逻辑就是流量玩法，上架市场，买量，赚广告费。因为gp上架越来越难，就衍生出一种玩法叫AB面。关于AB面，这里先不讲，主要说说B包的资源处理。这篇没技术，单纯自己记下来当笔记用。&lt;/p&gt;
&lt;h1 id=&quot;id&quot;&gt;&lt;a href=&quot;#id&quot; class=&quot;headerlink&quot; title=&quot;id&quot;&gt;&lt;/a&gt;id&lt;/h1&gt;&lt;p&gt;id其实是个整数，应用内的id一般情况是&lt;code&gt;0x7fxxxxxx&lt;/code&gt;，这个hex其实是&lt;code&gt;package&lt;/code&gt;,&lt;code&gt;type&lt;/code&gt;,&lt;code&gt;value&lt;/code&gt;的结构。而代码中如果有R.id.xx，会在编译时直接替换成该整数。做AB面的包，B包都是通过动态加载的，这就导致这个整数，必须在使用时，和你的资源对应。10年有，有种粗暴的解决办法，就是构建一个自己的aapt，可以指定&lt;code&gt;package&lt;/code&gt;，也就是前面的&lt;code&gt;7f&lt;/code&gt;，然后再用添加Resources的方式，将资源添加到资源管理器中。这样就能一劳永逸。B包打包，使用0x7e的资源，A包不处理，这样AB的资源就不会冲突。&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;android&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    aaptOptions &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        additionalParameters &lt;span class=&quot;string&quot;&gt;&amp;quot;--package-id&amp;quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;quot;0x7E&amp;quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;quot;--allow-reserved-package-id&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="android" scheme="https://lefo.me/categories/android/"/>
    
    
    <category term="android" scheme="https://lefo.me/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>遥遥领先的DNS配置</title>
    <link href="https://lefo.me/2025/08/18/fk-hw-dns/"/>
    <id>https://lefo.me/2025/08/18/fk-hw-dns/</id>
    <published>2025-08-18T15:01:19.000Z</published>
    <updated>2025-10-24T04:45:37.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前在家里的开发机上配了科技，但是媳妇的遥遥领先手机一直使用不了，大概排查了一下，应该是dns解析的问题，因为我把我路由fake ip的下一跳指到了内网一台设备上，但是我用工具查下一跳还是移动网关(10.41.x.x)。不能忍，开tcpdump查。</p><span id="more"></span><h1 id="流量"><a href="#流量" class="headerlink" title="流量"></a>流量</h1><p>直接在网关上开tcpdump</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i &lt;interface&gt; | grep &lt;local ip&gt;</span><br></pre></td></tr></table></figure><p>经过简单跟踪，发现该手机有一个<code>ecs-49-4-x-x.compute.hwclouds-dns.com</code>的请求，端口是5223，后面还有443的请求，盲猜应该是DNS和DoT的请求。开iptables封ip段。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A FORWARD -d 49.4.0.0/16 -j DROP</span><br></pre></td></tr></table></figure><p>封了后成功了，结果刚刷了两个网页，又无效了，再查发现ip段换了。刚好ecs后面跟的就是ip。</p><h1 id="kill-domain"><a href="#kill-domain" class="headerlink" title="kill domain"></a>kill domain</h1><p>上mosdns直接封死域名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tag: &quot;fck_hw&quot;</span><br><span class="line">type: &quot;sequence&quot;</span><br><span class="line">args:  # []rule</span><br><span class="line">  - matches:                # []string, 匹配条件。多个匹配条件为 AND 关系。</span><br><span class="line">    - qname domain:hwclouds-dns.com      # 封死当前及所有子域</span><br><span class="line">    exec: reject 3 </span><br></pre></td></tr></table></figure><p>搞定收摊</p><h1 id="总结如下："><a href="#总结如下：" class="headerlink" title="总结如下："></a>总结如下：</h1><p>遥遥领先应该是做了某种服务，优先使用它的dns。大致如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VPN &gt; HUAWEI DNS &gt; ROUTE DNS</span><br></pre></td></tr></table></figure><p>这也就是为什么用手机开启VPN服务可以，但是直接配网关就不行，这次封了它的dns域名，就默认走网络的配置了。忍不住想吐槽，你既然自己搞了DNS，还装模作样的在wifi里留什么dns地址，又骚又狗。之前在网上看说关闭安全dns，但我的手机本没有开，这套流程就是默认内置的。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;之前在家里的开发机上配了科技，但是媳妇的遥遥领先手机一直使用不了，大概排查了一下，应该是dns解析的问题，因为我把我路由fake ip的下一跳指到了内网一台设备上，但是我用工具查下一跳还是移动网关(10.41.x.x)。不能忍，开tcpdump查。&lt;/p&gt;</summary>
    
    
    
    <category term="linux" scheme="https://lefo.me/categories/linux/"/>
    
    
    <category term="linux" scheme="https://lefo.me/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>android 14安装CA证书</title>
    <link href="https://lefo.me/2025/07/31/android-14-install-ca/"/>
    <id>https://lefo.me/2025/07/31/android-14-install-ca/</id>
    <published>2025-07-31T09:18:29.000Z</published>
    <updated>2025-10-24T04:45:37.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前两天给模拟器上安装CA证书，发现即使放入<code>/system/etc/security/cacerts/</code>，依然不能用Charles抓包，设置里查看，证书也没有生效，终于找到了一篇详细介绍原因的文章，记录一下，以后更好找。</p><h1 id="准备证书"><a href="#准备证书" class="headerlink" title="准备证书"></a>准备证书</h1><p>准备你的SSL证书，重命名。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -inform PEM -subject_hash_old -<span class="keyword">in</span> charles_ssl.pem | <span class="built_in">head</span> -1</span><br><span class="line"><span class="comment">#将证书命名为得到的的结果.0</span></span><br><span class="line">adb push xxxxxx.0 /sdcard/</span><br></pre></td></tr></table></figure><span id="more"></span><h1 id="配置avd"><a href="#配置avd" class="headerlink" title="配置avd"></a>配置avd</h1><p>首先你得是可写入的模拟器，所以运行以下shell，注意替换你的Device</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">emulator -avd Pixel_API_34 -writable-system</span><br><span class="line">adb root</span><br><span class="line">adb remount</span><br></pre></td></tr></table></figure><p>将下列脚本保存成sh文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create a separate temp directory, to hold the current certificates</span></span><br><span class="line"><span class="comment"># Otherwise, when we add the mount we can&#x27;t read the current certs anymore.</span></span><br><span class="line"><span class="built_in">mkdir</span> -p -m 700 /data/local/tmp/tmp-ca-copy</span><br><span class="line"></span><br><span class="line"><span class="comment"># Copy out the existing certificates</span></span><br><span class="line"><span class="built_in">cp</span> /apex/com.android.conscrypt/cacerts/* /data/local/tmp/tmp-ca-copy/</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create the in-memory mount on top of the system certs folder</span></span><br><span class="line">mount -t tmpfs tmpfs /system/etc/security/cacerts</span><br><span class="line"></span><br><span class="line"><span class="comment"># Copy the existing certs back into the tmpfs, so we keep trusting them</span></span><br><span class="line"><span class="built_in">mv</span> /data/local/tmp/tmp-ca-copy/* /system/etc/security/cacerts/</span><br><span class="line"></span><br><span class="line"><span class="comment"># Copy our new cert in, so we trust that too</span></span><br><span class="line"><span class="built_in">mv</span> <span class="variable">$CERTIFICATE_PATH</span> /system/etc/security/cacerts/</span><br><span class="line"></span><br><span class="line"><span class="comment"># Update the perms &amp; selinux context labels</span></span><br><span class="line"><span class="built_in">chown</span> root:root /system/etc/security/cacerts/*</span><br><span class="line"><span class="built_in">chmod</span> 644 /system/etc/security/cacerts/*</span><br><span class="line"><span class="built_in">chcon</span> u:object_r:system_file:s0 /system/etc/security/cacerts/*</span><br><span class="line"></span><br><span class="line"><span class="comment"># Deal with the APEX overrides, which need injecting into each namespace:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># First we get the Zygote process(es), which launch each app</span></span><br><span class="line">ZYGOTE_PID=$(pidof zygote || <span class="literal">true</span>)</span><br><span class="line">ZYGOTE64_PID=$(pidof zygote64 || <span class="literal">true</span>)</span><br><span class="line"><span class="comment"># N.b. some devices appear to have both!</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Apps inherit the Zygote&#x27;s mounts at startup, so we inject here to ensure</span></span><br><span class="line"><span class="comment"># all newly started apps will see these certs straight away:</span></span><br><span class="line"><span class="keyword">for</span> Z_PID <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$ZYGOTE_PID</span>&quot;</span> <span class="string">&quot;<span class="variable">$ZYGOTE64_PID</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$Z_PID</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        nsenter --mount=/proc/<span class="variable">$Z_PID</span>/ns/mnt -- \</span><br><span class="line">            /bin/mount --<span class="built_in">bind</span> /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Then we inject the mount into all already running apps, so they</span></span><br><span class="line"><span class="comment"># too see these CA certs immediately:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Get the PID of every process whose parent is one of the Zygotes:</span></span><br><span class="line">APP_PIDS=$(</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$ZYGOTE_PID</span> <span class="variable">$ZYGOTE64_PID</span>&quot;</span> | \</span><br><span class="line">    xargs -n1 ps -o <span class="string">&#x27;PID&#x27;</span> -P | \</span><br><span class="line">    grep -v PID</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Inject into the mount namespace of each of those apps:</span></span><br><span class="line"><span class="keyword">for</span> PID <span class="keyword">in</span> <span class="variable">$APP_PIDS</span>; <span class="keyword">do</span></span><br><span class="line">    nsenter --mount=/proc/<span class="variable">$PID</span>/ns/mnt -- \</span><br><span class="line">        /bin/mount --<span class="built_in">bind</span> /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts &amp;</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">wait</span> <span class="comment"># Launched in parallel - wait for completion here</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;System certificate injected&quot;</span></span><br></pre></td></tr></table></figure><p>将sh脚本推送到任意目录，然后配一个CERTIFICATE_PATH变量，然后执行sh</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">adb push install-ca.sh /data/local/</span><br><span class="line">adb shell</span><br><span class="line">export CERTIFICATE_PATH=/sdcard/xxxxxx.0</span><br><span class="line">chmod +x /data/local/install-ca.sh</span><br><span class="line">/data/local/install-ca.sh</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://httptoolkit.com/blog/android-14-install-system-ca-certificate/">代码摘自这里</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前两天给模拟器上安装CA证书，发现即使放入&lt;code&gt;/system/etc/security/cacerts/&lt;/code&gt;，依然不能用Charles抓包，设置里查看，证书也没有生效，终于找到了一篇详细介绍原因的文章，记录一下，以后更好找。&lt;/p&gt;
&lt;h1 id=&quot;准备证书&quot;&gt;&lt;a href=&quot;#准备证书&quot; class=&quot;headerlink&quot; title=&quot;准备证书&quot;&gt;&lt;/a&gt;准备证书&lt;/h1&gt;&lt;p&gt;准备你的SSL证书，重命名。&lt;/p&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;openssl x509 -inform PEM -subject_hash_old -&lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; charles_ssl.pem | &lt;span class=&quot;built_in&quot;&gt;head&lt;/span&gt; -1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#将证书命名为得到的的结果.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;adb push xxxxxx.0 /sdcard/&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="android" scheme="https://lefo.me/categories/android/"/>
    
    
    <category term="android" scheme="https://lefo.me/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>mac mini配合linux当服务器使用</title>
    <link href="https://lefo.me/2025/04/24/macmini/"/>
    <id>https://lefo.me/2025/04/24/macmini/</id>
    <published>2025-04-24T15:39:17.000Z</published>
    <updated>2025-10-24T04:45:37.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我主业是安卓开发，但不务正业的我又在折腾别的了。</p><p>之前写过一篇关于 NX54 如何配置 iptables 以开放指定 IP 的 IPv6 防火墙规则。最近又把手上的一块 14 年的废弃 ARM 开发板翻出来，挂了块硬盘，让我在任意设备上都能访问家里的网络。要说这块板子，官方系统只到ubuntu 2014，连python3都没法装，之前折腾过armbian，但kernel有问题，usb不工作。最近看论坛去年有人升级了内核了，赶紧换一下系统。</p><p>过年期间家属送了一台 Mac mini（现在百亿补贴入手价 2899，血亏 600），于是我又折腾了一下，把整个网络重新整理了一遍。熬了几个夜晚和午休时间，总算弄好了，这里记录一下过程中遇到的问题和解决方案。</p><h1 id="之前我做了什么"><a href="#之前我做了什么" class="headerlink" title="之前我做了什么"></a>之前我做了什么</h1><ol><li>桥接路由，这样可以直接获取公网ipv6地址，供自己在外边连接。</li><li>关防火墙。大多数路由器都有ipv6防火墙，像我的NX54就是基于ip6tables的配置，需要关掉。我是只关掉了我的linux的ip。我使用了脚本自动更新，脚本流程如下： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linux定时任务 -&gt; python脚本 -&gt; 获取ipv6 -&gt; 发现变化 -&gt; 更新nx54防火墙 -&gt; 更新cloudflare dns AAAA(最早做了一版发email的，后来改ddns了)</span><br></pre></td></tr></table></figure> 不得不说，cloudflare真的是互联网之光，域名便宜，免费加速，还提供Pages，Workers。</li><li>linux关闭ssh密码访问，把常用的设备公钥加进去。<span id="more"></span>经过上面的配置，外网只能通过IPV6访问到linux，利用SSH建立隧道，还能连接家里的电脑，方便又安全。</li></ol><h1 id="Mac-mini准备"><a href="#Mac-mini准备" class="headerlink" title="Mac mini准备"></a>Mac mini准备</h1><h2 id="能源"><a href="#能源" class="headerlink" title="能源"></a>能源</h2><ul><li>✅ 防止进入睡眠 </li><li>✅ 唤醒以供网络访问</li><li>❌ 如有可能，将硬盘置于睡眠状态 </li><li>✅ 断电自动重启</li></ul><h2 id="远程桌面"><a href="#远程桌面" class="headerlink" title="远程桌面"></a>远程桌面</h2><p>设置 -&gt; 通用 -&gt; 共享 -&gt; 屏幕共享 &amp; 远程登录 &amp; 文件共享<br>mac支持屏幕分享，但是是通过vnc:&#x2F;&#x2F;协议访问的，如果要通过ARD，那还需要花几百块买软件。平替方案：走ssh通道</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -L 5900:192.168.x.x:5900 username@linux_ipv6</span><br></pre></td></tr></table></figure><p>command + spcae  屏幕分享  输入localhost就能连了，如此一来就是加密的。本来我是准备用wireguard去连接的，但一直没从10.0.0.0穿透到192.168.x.x，不好直接用ssh隧道更方便。</p><h2 id="打开自动登录"><a href="#打开自动登录" class="headerlink" title="打开自动登录"></a>打开自动登录</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">设置 -&gt; 用户与群组 -&gt; 自动以此身份登录</span><br></pre></td></tr></table></figure><p>这一项非常关键，不然重启后就卡在登录界面，需要手动输入密码。</p><h1 id="服务开机启动"><a href="#服务开机启动" class="headerlink" title="服务开机启动"></a>服务开机启动</h1><p>适用一些需要开机启动的服务，和linux不一样，使用launchctl管理。注意脚本不要放在Documents，没权限访问，自己在~下新建一个</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">plist</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//Apple//DTD PLIST 1.0//EN&quot;</span> <span class="string">&quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plist</span> <span class="attr">version</span>=<span class="string">&quot;1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 唯一的标识符 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>Label<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>yourshell.startup<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 要执行的命令 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>ProgramArguments<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">string</span>&gt;</span>/path/to/yourshell.sh<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 在加载时自动启动 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>RunAtLoad<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 如果脚本停止，保持脚本运行 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>KeepAlive<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 丢弃标准输出 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>StandardOutPath<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>/Dev/null<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 丢弃标准错误输出 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>StandardErrorPath<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>/Dev/null<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plist</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 停止</span><br><span class="line">sudo launchctl bootout gui/$(id -u) ~/Library/LaunchAgents/yourshell.startup.plist</span><br><span class="line"># 加载</span><br><span class="line">sudo launchctl bootstrap gui/$(id -u) ~/Library/LaunchAgents/yourshell.startup.plist</span><br></pre></td></tr></table></figure><h1 id="打通转发-linux-Mac-mini🪜"><a href="#打通转发-linux-Mac-mini🪜" class="headerlink" title="打通转发(linux -&gt; Mac mini🪜)"></a>打通转发(linux -&gt; Mac mini🪜)</h1><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>我使用 Linux 网关配合 MosDNS 进行 DNS 分流：<code>直连流量</code>不处理，访问<code>内部网站</code>解析虚拟ip，然后通过 iptables 进行路由转发。由于 Mac 不支持 TPROXY，所以我在 Mac 上运行 SOCKS 代理，然后在 Linux 上使用 TPROXY 转发连接到 SOCKS。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># 修改iptables</span><br><span class="line">iptables -t mangle -N MYWAY 2&gt;/dev/null</span><br><span class="line">iptables -t mangle -F MYWAY</span><br><span class="line">iptables -t mangle -A MYWAY -d 198.18.0.0/16 -p tcp -j TPROXY --on-port &lt;tproxy_port&gt; --tproxy-mark 1</span><br><span class="line">iptables -t mangle -A MYWAY -d 198.18.0.0/16 -p udp -j TPROXY --on-port &lt;tproxy_port&gt; --tproxy-mark 1</span><br><span class="line">iptables -t mangle -D PREROUTING -j MYWAY 2&gt;/dev/null</span><br><span class="line">iptables -t mangle -A PREROUTING -j MYWAY</span><br><span class="line"></span><br><span class="line"># 开启NAT转发</span><br><span class="line">echo &quot;net.ipv4.ip_forward = 1&quot; | sudo tee -a /etc/sysctl.conf</span><br><span class="line">echo &quot;net.ipv4.conf.all.route_localnet=1&quot; | sudo tee -a /etc/sysctl.conf</span><br><span class="line">sysctl -p</span><br><span class="line"></span><br><span class="line"># nat转换 注意这里区分你的网络接口</span><br><span class="line">iptables -t nat -A POSTROUTING -o end0 -j MASQUERADE</span><br><span class="line"></span><br><span class="line"># 路由 注意这两条也要保存到rc.local，不然重启后就失效了。</span><br><span class="line">ip rule add fwmark 1 lookup 100</span><br><span class="line">ip route add local 0 0.0.0/0 dev lo table 100</span><br><span class="line"></span><br><span class="line"># 保存 iptables配置</span><br><span class="line">sudo iptables-save | sudo tee -a /etc/iptables/rules.v4</span><br><span class="line">sudo nano /etc/rc.local</span><br><span class="line"># 添加 iptables-restore &lt; /etc/iptables/rules.v4</span><br><span class="line"># 添加 ip rule add fwmark 1 lookup 100</span><br><span class="line"># 添加 ip route add local 0 0.0. 0/0 dev lo table 100</span><br><span class="line"># 保存</span><br><span class="line"></span><br><span class="line"># 确保有执行权限</span><br><span class="line">sudo chmod +x /etc/rc.local</span><br></pre></td></tr></table></figure><p>最终实现的效果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">📱 手机（或其他设备）</span><br><span class="line">│</span><br><span class="line">├── 发起请求（例如：访问 https://www.example.com）</span><br><span class="line">│</span><br><span class="line">├── 📡 DNS 请求发送至 ➜ 192.168.x.115（网关设备上的 MosDNS）</span><br><span class="line">│</span><br><span class="line">│   └─ MosDNS 分流：</span><br><span class="line">│       ├─ 直连域名 → 直连（返回真实 IP）</span><br><span class="line">│       └─ 内部域名 → 发给 113 上的 DNS服务</span><br><span class="line">│</span><br><span class="line">│       └─ DNS服务 返回 fake-ip（如 198.18.0.x）</span><br><span class="line">│</span><br><span class="line">└── 手机收到 fake-ip（例如 198.18.0.33）后发起连接</span><br><span class="line">     ↓</span><br><span class="line">     发出 TCP 请求目标：198.18.0.33:443</span><br><span class="line">     ↓</span><br><span class="line">━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━</span><br><span class="line">🛡️ 网关设备（115）iptables 检测</span><br><span class="line">│</span><br><span class="line">├── mangle 表匹配到 fake-ip 段（198.18.0.0/16）</span><br><span class="line">│</span><br><span class="line">├── TPROXY 重定向流量 → 本地转换服务</span><br><span class="line">│</span><br><span class="line">├── 路由策略：</span><br><span class="line">│   └─ fwmark=1 → local via lo（回送至本地转换服务</span><br><span class="line">│</span><br><span class="line">└── 本地转换服务 接收到TPROXY流量</span><br><span class="line">    ↓</span><br><span class="line">    转发至 代理服务（113）的 Socks 服务</span><br><span class="line">━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━</span><br><span class="line">🧱 代理服务（113）处理流量</span><br><span class="line">│</span><br><span class="line">└── 访问目标网站（如 example.com），建立 TLS 连接</span><br><span class="line">    ↓</span><br><span class="line">    返回响应</span><br><span class="line">━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━</span><br><span class="line">⬆️ 回程流量返回手机，访问完成</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结，其实就是将115上开启转发，fake-ip段标记1，进TPROXY，再走socks发到mac mini</p><h2 id="踩过的坑"><a href="#踩过的坑" class="headerlink" title="踩过的坑"></a>踩过的坑</h2><p>有些细节不说了，我还有份详细的笔记，但不方便暴露。这里走了点弯路，踩坑总结：</p><ol><li>tproxy to socks 本来尝试用工具redsocks，AI说不支持udp，放弃了。改用另一款，性能稍微差点，但支持的协议多，配置也简单。</li><li>一定要配<code>echo &quot;net.ipv4.conf.all.route_localnet=1&quot; | sudo tee -a /etc/sysctl.conf</code> 这一项才允许路由lo，我本身对linux的网络熟练度低，就因为这个配置，搞了好久，AI也一直没讲，后面一点点查到的。</li><li>起初直接使用 TUN 实现，毕竟是个虚拟网卡，招呼了所有流量，后来觉得不够优雅，最终改成 DNS分流 + TPROXY + SOCKS，感谢一位哥们跟我交流后确定了方向。</li><li>为什么非要建在mac上，因为开发板性能太差，虽然还能撑，但能少安服务就少安吧，况且在新mac上加一个这个服务跑，完全不受影响。我在linux上面还有个Alist(板子原生支持SATA，就接了块电脑硬盘)。</li><li>linux上有个systemd-resolved，记得disable，占了53端口。当然也可以不做，需要设备上指定DNS端口。</li></ol><h1 id="居然是冰的"><a href="#居然是冰的" class="headerlink" title="居然是冰的"></a>居然是冰的</h1><p>Mac mini跑好几天了，摸一摸表面居然是冰的。家里养猫，PDD 26买了个3D打印的底座，不是15块那个，不是一个做工。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><ol><li>我把科技的服务搭在了我的linux板子上，发现开网页变的很慢，curl差不多，猜测是机器太老，线程不够，放弃了，又转回来mac mini了。</li><li>不想手改ip网关了，就在nx54路由器上配了个静态路由<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip route add 198.18.0.0/16 via 192.168.x.115 dev br-lan</span><br></pre></td></tr></table></figure></li><li>115如果也想一样，需要标记一下OUTPUT链<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -t mangle -A OUTPUT -d 198.18.0.0/16 -p tcp -j MARK --set-mark 1</span><br><span class="line">iptables -t mangle -A OUTPUT -d 198.18.0.0/16 -p udp -j MARK --set-mark 1</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;我主业是安卓开发，但不务正业的我又在折腾别的了。&lt;/p&gt;
&lt;p&gt;之前写过一篇关于 NX54 如何配置 iptables 以开放指定 IP 的 IPv6 防火墙规则。最近又把手上的一块 14 年的废弃 ARM 开发板翻出来，挂了块硬盘，让我在任意设备上都能访问家里的网络。要说这块板子，官方系统只到ubuntu 2014，连python3都没法装，之前折腾过armbian，但kernel有问题，usb不工作。最近看论坛去年有人升级了内核了，赶紧换一下系统。&lt;/p&gt;
&lt;p&gt;过年期间家属送了一台 Mac mini（现在百亿补贴入手价 2899，血亏 600），于是我又折腾了一下，把整个网络重新整理了一遍。熬了几个夜晚和午休时间，总算弄好了，这里记录一下过程中遇到的问题和解决方案。&lt;/p&gt;
&lt;h1 id=&quot;之前我做了什么&quot;&gt;&lt;a href=&quot;#之前我做了什么&quot; class=&quot;headerlink&quot; title=&quot;之前我做了什么&quot;&gt;&lt;/a&gt;之前我做了什么&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;桥接路由，这样可以直接获取公网ipv6地址，供自己在外边连接。&lt;/li&gt;
&lt;li&gt;关防火墙。大多数路由器都有ipv6防火墙，像我的NX54就是基于ip6tables的配置，需要关掉。我是只关掉了我的linux的ip。我使用了脚本自动更新，脚本流程如下： &lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;linux定时任务 -&amp;gt; python脚本 -&amp;gt; 获取ipv6 -&amp;gt; 发现变化 -&amp;gt; 更新nx54防火墙 -&amp;gt; 更新cloudflare dns AAAA(最早做了一版发email的，后来改ddns了)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
 不得不说，cloudflare真的是互联网之光，域名便宜，免费加速，还提供Pages，Workers。&lt;/li&gt;
&lt;li&gt;linux关闭ssh密码访问，把常用的设备公钥加进去。</summary>
    
    
    
    <category term="linux" scheme="https://lefo.me/categories/linux/"/>
    
    
    <category term="linux" scheme="https://lefo.me/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>GmSSL中的totp</title>
    <link href="https://lefo.me/2024/12/31/sm3-totp/"/>
    <id>https://lefo.me/2024/12/31/sm3-totp/</id>
    <published>2024-12-31T09:40:31.000Z</published>
    <updated>2025-10-24T04:45:37.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>越来越多的网站像Github一样开启了2次验证，给你生成一个6位的数字动态口令，这种就叫TOTP，通俗讲，就是基于时间的一次性动态口令。我在家里搭了个Alist文件服务器，也默认支持TOTP，不过我开了HTTPS，用的也不多，TOTP验证就关了。我为什么要看这个呢，上班的地方wifi使用了h3c e盾认证，里面使用了SM3计算口令，每次连wifi还得点开app，索性看看它是怎么计算的。</p><span id="more"></span><h1 id="TOTP介绍"><a href="#TOTP介绍" class="headerlink" title="TOTP介绍"></a>TOTP介绍</h1><p>首先我们看一下Github二次验证，它会给我们一个二维码，让我们用Authenticator类似的软件扫一扫，然后就能添加。如果我们用别的软件扫，会得到一个如下的地址：(来源互联网的二维码)</p><blockquote><p>otpauth:&#x2F;&#x2F;totp&#x2F;GitHub:user?secret&#x3D;MMJCO5MSOUN57MGT&amp;issuer&#x3D;GitHub</p></blockquote><p>这里我们主要关注的是secret，128bit的key，其它参数都是用来在软件上显示的，其实你可以随意修改。软件会用secret + 时间值计算一个hash，并截取6位作为口令值。服务端校验时，通常会计算前一个或者后一个值，用来容错对比。</p><ul><li>TOTP生成：TOTP(K,T) &#x3D; Truncate(HMAC-HASH(K,T))，其中HASH&#x3D;SHA-1&#x2F;SHA-256&#x2F;SHA-512</li></ul><p>对上述参数做简单说明：</p><ol><li>K就是你的密钥，也就是secret</li><li>T为时间因子，一般时间戳(秒) &#x2F; 步长。如30s一刷新，那就是当前时间戳(秒) &#x2F; 30。</li></ol><h1 id="GmSSL"><a href="#GmSSL" class="headerlink" title="GmSSL"></a>GmSSL</h1><blockquote><p>otpauth:&#x2F;&#x2F;totp&#x2F;lefo:lefo?secret&#x3D;MMJCO5MSOUN57MGT&amp;algorithm&#x3D;sm3</p></blockquote><p>GmSSL中，SM3 SM4算法可以用来生成一次性口令，日常使用中，也是一个链接生成的二维码，与常规totp的二维码无异，只是后面会跟一个参数用来标记使用sm3&#x2F;sm4算法。但算法并不是替换就行，还多了两项参数。</p><ul><li>GMOTP生成：GMOTP(K,T|C|Q)&#x3D;Truncate(F(K,T|C|Q))，其中F&#x3D;SM3&#x2F;SM4</li></ul><p>其中，C为事件因子，8字节整数。Q为挑战因子，4字节整数。均可省略。将这些参数拼接起来，再调用SM3&#x2F;SM4算法。</p><h1 id="国标GmSSL-TOTP"><a href="#国标GmSSL-TOTP" class="headerlink" title="国标GmSSL TOTP"></a>国标GmSSL TOTP</h1><p>全国标准信息公共服务平台有一项规范为《信息安全技术 动态口令密码应用技术规范》，内部介绍了SM3 SM4计算totp的方法，其中Truncate计算和常规totp计算也不一样。在常规totp中，是取最后4字节，但是在该规范中，32个字节分为8组，将所有4字节整数求和。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>规范中的扩展（推测）</strong></th></tr></thead><tbody><tr><td>参数为 K 和 T</td><td>参数为 K、T、C、Q</td></tr><tr><td>使用标准哈希算法（SHA-1、SHA-256）</td><td>使用国密算法</td></tr><tr><td>Truncate 步骤使用偏移量截取 4 字节</td><td>可能分组为 8 部分（S1-S8），通过计算决定截取部分</td></tr></tbody></table><ul><li><a href="https://openstd.samr.gov.cn/bzgk/gb/newGbInfo?hcno=FBCA58A4BF07DD668D7480D5A3C8DFE4">GB&#x2F;T 38556-2020 信息安全技术 动态口令密码应用技术规范</a></li><li><a href="https://github.com/lephones/GmSSL-totp">GmSSL-totp</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;越来越多的网站像Github一样开启了2次验证，给你生成一个6位的数字动态口令，这种就叫TOTP，通俗讲，就是基于时间的一次性动态口令。我在家里搭了个Alist文件服务器，也默认支持TOTP，不过我开了HTTPS，用的也不多，TOTP验证就关了。我为什么要看这个呢，上班的地方wifi使用了h3c e盾认证，里面使用了SM3计算口令，每次连wifi还得点开app，索性看看它是怎么计算的。&lt;/p&gt;</summary>
    
    
    
    <category term="gmssl" scheme="https://lefo.me/categories/gmssl/"/>
    
    
    <category term="gmssl" scheme="https://lefo.me/tags/gmssl/"/>
    
    <category term="sm3" scheme="https://lefo.me/tags/sm3/"/>
    
    <category term="totp" scheme="https://lefo.me/tags/totp/"/>
    
  </entry>
  
  <entry>
    <title>nx54的ipv6配置nas，内网穿透访问，nxginx、DDNS都在这里</title>
    <link href="https://lefo.me/2024/11/18/nas-ipv6/"/>
    <id>https://lefo.me/2024/11/18/nas-ipv6/</id>
    <published>2024-11-18T04:52:33.000Z</published>
    <updated>2025-10-24T04:45:37.608Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上一篇说到nx54路由器如何在官方防火墙上加一个自己主机允许访问的规则，在不关闭防火墙的情况下，还能走ipv6访问到内网设备，里面有提到ipv6地址变化的问题。这篇主要说说ipv6变化后如何通知你，通知路由器，以及一部分nginx配置心得。</p><h1 id="ip变化通知，同时更新路由防火墙规则"><a href="#ip变化通知，同时更新路由防火墙规则" class="headerlink" title="ip变化通知，同时更新路由防火墙规则"></a>ip变化通知，同时更新路由防火墙规则</h1><blockquote><p>注意以下所说的ip都是指ipv6，因为ipv4内网地址可以直接和mac地址绑定，不用通知你。</p></blockquote><span id="more"></span><p>我发现新固件在重启设备后，ip也不会变了，这算是一个好事吧，也不用经常更新ip地址。不过，以防正需用的时候ip地址变化。我使用的是python脚本，当检测到ip变化，就向我的邮箱发送一封email。(你也可以直接做DDNS，自己写api调用脚本或者ddns-go)。有几点要求：</p><ol><li>你的邮箱开通smtp，smtp是一个用于发邮件的，一般在邮箱的设置页。</li><li>你的路由已经常开telnet，参考之前的文章，我因为找到了常开方式，直接常开了。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket  </span><br><span class="line"><span class="keyword">import</span> smtplib  </span><br><span class="line"><span class="keyword">import</span> subprocess </span><br><span class="line"><span class="keyword">import</span> os  </span><br><span class="line"><span class="keyword">import</span> telnetlib</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText  </span><br><span class="line"><span class="keyword">from</span> email.mime.multipart <span class="keyword">import</span> MIMEMultipart  </span><br><span class="line"></span><br><span class="line"><span class="comment"># Telnet 连接信息</span></span><br><span class="line">HOST = <span class="string">&quot;192.168.124.1&quot;</span> <span class="comment"># 路由的ip</span></span><br><span class="line">PORT = <span class="number">15000</span></span><br><span class="line">PASSWORD = <span class="string">&quot;password&quot;</span>  <span class="comment"># 替换为实际密码</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置发件人和收件人信息  </span></span><br><span class="line">sender_email = <span class="string">&#x27;发件邮箱&#x27;</span></span><br><span class="line">password = <span class="string">&#x27;smtp password&#x27;</span>  <span class="comment"># 一般都有SMTP应用专用密码 </span></span><br><span class="line"><span class="comment"># 设置SMTP服务器地址和端口  我使用的是126，qq和网易都支持SSL，能避免密码明文传输</span></span><br><span class="line">smtp_server = <span class="string">&#x27;smtp.126.com&#x27;</span>  </span><br><span class="line">smtp_port = <span class="number">465</span>  <span class="comment"># 通常是587用于TLS或465用于SSL  SMTP默认是25，但是25不加密，我们使用SSL，网易支持SSL</span></span><br><span class="line">receiver_email = <span class="string">&#x27;接收ip的邮箱&#x27;</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个socket对象  主要是为了获取主机名，其实没什么用</span></span><br><span class="line">sock = socket.socket(socket.AF_INET6, socket.SOCK_DGRAM)  </span><br><span class="line"></span><br><span class="line">save_ip = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">save_ip_string_to_file</span>(<span class="params">ip_string, filename=<span class="string">&quot;ip_string.txt&quot;</span></span>):  </span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> file:  </span><br><span class="line">        file.write(ip_string)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_ip_string_in_file</span>(<span class="params">ip_string, filename=<span class="string">&quot;ip_string.txt&quot;</span></span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(filename):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span> :  </span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> file:  </span><br><span class="line">            file_content = file.read()  </span><br><span class="line">            <span class="keyword">return</span> file_content == ip_string </span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_host_name</span>():</span><br><span class="line">    <span class="comment"># 获取主机名  </span></span><br><span class="line">    host_name = socket.gethostname()  </span><br><span class="line">    <span class="keyword">return</span> host_name</span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_ipv6_addresses</span>():  </span><br><span class="line">    <span class="comment"># 执行ip -6 addr命令获取IPv6地址信息  </span></span><br><span class="line">    result = subprocess.run([<span class="string">&#x27;ip&#x27;</span>, <span class="string">&#x27;-6&#x27;</span>, <span class="string">&#x27;addr&#x27;</span>], capture_output=<span class="literal">True</span>, text=<span class="literal">True</span>)  </span><br><span class="line">    <span class="comment">#result = subprocess.run([&#x27;ip&#x27;, &#x27;-6&#x27;, &#x27;addr&#x27;], stdout=subprocess.PIPE, stdin=subprocess.PIPE, universal_newlines=True)   #python 3.6</span></span><br><span class="line">    <span class="keyword">if</span> result.returncode != <span class="number">0</span>:  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error executing ip command&quot;</span>)  </span><br><span class="line">        <span class="keyword">return</span> []  </span><br><span class="line">      </span><br><span class="line">    <span class="comment"># 解析输出以获取IPv6地址  </span></span><br><span class="line">    lines = result.stdout.split(<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">    ipv6_addresses = []  </span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:  </span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;inet6&#x27;</span> <span class="keyword">in</span> line <span class="keyword">and</span> <span class="string">&#x27;dynamic mngtmpaddr noprefixroute&#x27;</span> <span class="keyword">in</span> line <span class="keyword">and</span> <span class="string">&#x27; deprecated &#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> line:  </span><br><span class="line">            <span class="comment"># 查找inet6行中的IPv6地址  </span></span><br><span class="line">            address = line.split(<span class="string">&#x27;inet6 &#x27;</span>)[<span class="number">1</span>].split(<span class="string">&#x27;/&#x27;</span>)[<span class="number">0</span>].strip()  </span><br><span class="line">            <span class="keyword">if</span> address != <span class="string">&#x27;::1&#x27;</span>:  <span class="comment"># 忽略本地回环地址  </span></span><br><span class="line">                ipv6_addresses.append(address)  </span><br><span class="line">               <span class="comment"># if ipv6_addresses.count() &gt; 5 :</span></span><br><span class="line">               <span class="comment">#     break;</span></span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span> ipv6_addresses </span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_email</span>(<span class="params">title, content</span>) :</span><br><span class="line">    <span class="comment"># 创建邮件对象  </span></span><br><span class="line">    msg = MIMEMultipart()  </span><br><span class="line">    msg[<span class="string">&#x27;From&#x27;</span>] = sender_email  </span><br><span class="line">    msg[<span class="string">&#x27;To&#x27;</span>] = receiver_email  </span><br><span class="line">    msg[<span class="string">&#x27;Subject&#x27;</span>] = title</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 添加邮件正文  </span></span><br><span class="line">    body = content</span><br><span class="line">    msg.attach(MIMEText(body, <span class="string">&#x27;plain&#x27;</span>))  </span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创建SMTP对象并发送邮件  </span></span><br><span class="line">    <span class="keyword">with</span> smtplib.SMTP_SSL(smtp_server, smtp_port) <span class="keyword">as</span> server:  </span><br><span class="line">        <span class="comment">#server.starttls()  # 启动TLS加密  </span></span><br><span class="line">        server.login(sender_email, password)  <span class="comment"># 登录邮箱  </span></span><br><span class="line">        text = msg.as_string()  <span class="comment"># 将邮件对象转换为字符串  </span></span><br><span class="line">        server.sendmail(sender_email, receiver_email, text)  <span class="comment"># 发送邮件  </span></span><br><span class="line">        server.quit()  <span class="comment"># 关闭连接  </span></span><br><span class="line">    </span><br><span class="line"><span class="comment">#    print(&quot;邮件发送成功！&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change_ip6tables</span>(<span class="params">ip6_addr</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 连接到目标主机</span></span><br><span class="line">        tn = telnetlib.Telnet(HOST, <span class="number">15000</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Connected to <span class="subst">&#123;HOST&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 等待并输入密码</span></span><br><span class="line">        <span class="comment">#tn.read_until(b&quot;Password: &quot;)</span></span><br><span class="line">        time.sleep(<span class="number">3</span>)</span><br><span class="line">        tn.write(PASSWORD.encode(<span class="string">&#x27;ascii&#x27;</span>) + <span class="string">b&quot;\n&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Password entered&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 执行 debugshell 命令</span></span><br><span class="line">        tn.write(<span class="string">b&quot;debugshell\n&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Entered debugshell&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 执行 ip6tables -F forwarding_rule 命令</span></span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        tn.write(<span class="string">b&quot;ip6tables -F forwarding_rule\n&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Flushed forwarding_rule&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 执行 ip6tables -A forwarding_rule -d device_ipv6 -j ACCEPT 命令</span></span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        add_rule_command = <span class="string">f&quot;ip6tables -A forwarding_rule -d <span class="subst">&#123;ip6_addr&#125;</span> -j ACCEPT\n&quot;</span></span><br><span class="line">        tn.write(add_rule_command.encode(<span class="string">&#x27;ascii&#x27;</span>))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Added ACCEPT rule for <span class="subst">&#123;ip6_addr&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 读取命令输出</span></span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        output = tn.read_very_eager().decode(<span class="string">&#x27;ascii&#x27;</span>)</span><br><span class="line">        <span class="comment">#print(&quot;Command output:\n&quot;, output)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 关闭连接</span></span><br><span class="line">        tn.write(<span class="string">b&quot;exit\n&quot;</span>)</span><br><span class="line">        tn.close()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Connection closed&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Error: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    host_name = get_host_name()</span><br><span class="line">    <span class="comment"># 获取并打印IPv6地址  </span></span><br><span class="line">    ipv6_addrs = get_ipv6_addresses()  </span><br><span class="line">    result = <span class="string">&#x27;\n&#x27;</span>.join(ipv6_addrs)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;IPv6地址: <span class="subst">&#123;result&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> check_ip_string_in_file(result) :</span><br><span class="line">        save_ip_string_to_file(result)</span><br><span class="line">        send_email(host_name + <span class="string">&#x27; ip &#x27;</span>,result)</span><br><span class="line">        change_ip6tables(result)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>简单说一下上面的逻辑，获取ip地址，当前目录会保存一个ip_string.txt，用来保存上一次获取的ip，如果不一致，就发送email，更新路由防火墙规则，同时保存新ip。获取ip其实是执行了一条 ip -6 addr 的指令，这条指令能获取多条ip，大部分是temp的，我过滤ip的条件有点冗余，可以根据自己要求配置。</li></ol><p>另外，我的脚本有一点点弊端，就是telnet联过路由后，后面是不用再输入密码的，但这里多输了一次，无伤大雅，毕竟你的密码不是一个可执行命令。</p><p>使用crontab -e，将你的脚本添加到定时任务自动执行，关于定时任务的配置，就不讲了。</p><h1 id="nginx-alist"><a href="#nginx-alist" class="headerlink" title="nginx &amp; alist"></a>nginx &amp; alist</h1><blockquote><p>关于SSH访问及控制，参考之前的文章。</p></blockquote><p>因为我主要是为了方便存储文件，跑了个alist，其实alist也是够用的，不用再装nginx，但有nginx，配置可以更灵活。alist支持otp动态密码，配合前面的email接收邮件，足够使用了。不过http毕竟是明文传输，我为了安全起见，还是装了ssl证书。我看alist的配置有ssl证书，但最后还是采用了nginx的反向代理，根据server控制更方便,内网外网控制更灵活。</p><p>如果你没有域名，搭建好后使用ip访问，也可以，但是let‘s encrypt的https就不能支持了，为了方便还是建议大家注册一个域名。</p><p>自己建服务器主要涉及以下几个问题：</p><ol><li>你的服务不要搭建在常规端口上。(80 443 445端口封锁，这三个通常用于http https smb协议。)</li><li>域名在国外服务商注册，且不要使用国内dns加速服务 (可能会有上报，当然流量追踪也可能被查。)</li><li>添加ssl (http是明文传输，尽量使用https)</li></ol><p>综上所述，大概配置要做到如下几点：</p><ol><li>alist的address配置为127.0.0.1，这样公网ip访问不到你的主alist服务。本来想再加内网ip，我尝试了一下，alist不能指定多个address，所以用反向代理。</li><li>nginx配置一个ssl server，server_name可以绑定你的域名，也可以写_。</li><li>nginx配置一个http server，端口可以是80，server_name使用你192.168.124.x的ipv4地址，供你内网访问。</li><li>以上两个nginx，全使用反向代理连接到alist，反向代理在alist的文档里有。</li></ol><p>做完以上操作，能达到的效果是：外网通过https走加密通道访问(注意端口)，内网可以直接通过192.168.124.x走http直接访问。</p><h1 id="ssl-ddns"><a href="#ssl-ddns" class="headerlink" title="ssl &amp; ddns"></a>ssl &amp; ddns</h1><p>没关系的两个内容为什么放一起写，因为ssl签发证书，只能通过dns认证，其它的方式要求80端口开放。</p><h2 id="ssl"><a href="#ssl" class="headerlink" title="ssl"></a>ssl</h2><ol><li>使用certbot，或者acme.sh申请证书，有效期90天。</li><li>因为80被封，只能手动改dns认证。它会要求你加一条txt解析，续期值会不一样。</li><li>如果你的域名服务商是cloudflare，有插件支持，没插件的服务商需要自己申请一下key，发请求。顺带说一下，godaddy的dns api大陆访问不了。</li><li>如果你能做了dns自动认证，那就加到crontab -e上，定时自动续期，这里不要太频繁，因为有效期有90天，可以两个月续一次。</li></ol><p>如果你脚本搞不定，90天手动更新一次也是可以的。</p><h2 id="ddns"><a href="#ddns" class="headerlink" title="ddns"></a>ddns</h2><p>如果你上面dns的一步搞定了，推荐你使用你的脚本，结合之前获取ip，自己做ddns。小白就使用ddns-go吧。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;上一篇说到nx54路由器如何在官方防火墙上加一个自己主机允许访问的规则，在不关闭防火墙的情况下，还能走ipv6访问到内网设备，里面有提到ipv6地址变化的问题。这篇主要说说ipv6变化后如何通知你，通知路由器，以及一部分nginx配置心得。&lt;/p&gt;
&lt;h1 id=&quot;ip变化通知，同时更新路由防火墙规则&quot;&gt;&lt;a href=&quot;#ip变化通知，同时更新路由防火墙规则&quot; class=&quot;headerlink&quot; title=&quot;ip变化通知，同时更新路由防火墙规则&quot;&gt;&lt;/a&gt;ip变化通知，同时更新路由防火墙规则&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;注意以下所说的ip都是指ipv6，因为ipv4内网地址可以直接和mac地址绑定，不用通知你。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="nx54" scheme="https://lefo.me/categories/nx54/"/>
    
    
    <category term="nas" scheme="https://lefo.me/tags/nas/"/>
    
    <category term="ipv6" scheme="https://lefo.me/tags/ipv6/"/>
    
  </entry>
  
  <entry>
    <title>H3C NX54不关ipv6防火墙，允许外网访问内网</title>
    <link href="https://lefo.me/2024/11/10/nx54-ip6tables/"/>
    <id>https://lefo.me/2024/11/10/nx54-ip6tables/</id>
    <published>2024-11-10T06:51:47.000Z</published>
    <updated>2025-10-24T04:45:37.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>NX54终于更新固件了，新版本支持配置关闭ipv6防火墙，但是，防火墙关闭，相对而言风险也就上来了。其实最好的办法是，在防火墙上稍微开一个小口就行了，也就是，只允许目标地址是你指定IP的数据通过，今天就大概说说如何最小风险去处理这件事情。主要有以下两个操作：</p><ol><li>ip6tables限制指定目标ip转发</li><li>关闭要访问的服务器的ssh访问，windows主机可忽略</li></ol><span id="more"></span><h1 id="限制只有访问你主机才能通过ipv6防火墙"><a href="#限制只有访问你主机才能通过ipv6防火墙" class="headerlink" title="限制只有访问你主机才能通过ipv6防火墙"></a>限制只有访问你主机才能通过ipv6防火墙</h1><p>nx54就是一个openwrt的魔改版本，所以防火墙是基于ip6tables的，简单说一下iptables，维护着一个规则链，所以要达到我们的预期，需要把允许的规则配置到前面。</p><h2 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h2><p>访问<a href="http://[ip]/debug.asp">http:&#x2F;&#x2F;[ip]&#x2F;debug.asp</a>，向下拉，找到telnet管理，勾选启动telnet，点旁边应用，在命令行执行如下命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">telnet &lt;路由ip&gt; 15000</span><br><span class="line"><span class="comment"># 输入密码</span></span><br><span class="line">&lt;your password&gt;</span><br><span class="line"><span class="comment"># &lt;H3C_NX54&gt;后输入 debugshell</span></span><br><span class="line">debugshell</span><br></pre></td></tr></table></figure><p>查看ip6tables的FORWARD配置，显示只有一项为delegate_forward，再看delegate_forward配置，包含5项，通过继续查看第一项forwarding_rule，发现这条配置其实是空的。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ip6tables -L FORWARD -v -n --line-numbers</span><br><span class="line"><span class="comment"># delegate_forward</span></span><br><span class="line"></span><br><span class="line">ip6tables -L delegate_forward -v -n --line-numbers</span><br><span class="line"><span class="comment"># forwarding_rule</span></span><br><span class="line"><span class="comment"># ACCEPT</span></span><br><span class="line"><span class="comment"># zone_lan_forward</span></span><br><span class="line"><span class="comment"># zone_wan_forward</span></span><br><span class="line"><span class="comment"># reject</span></span><br><span class="line"></span><br><span class="line">ip6tables -L forwarding_rule -v -n --line-numbers</span><br><span class="line"><span class="comment"># null</span></span><br></pre></td></tr></table></figure><p>简单说一下上面的意思，所有的转发流量，走delegate_forward，而delegate_forward分为了5步，如果前四步没有命中，那么会进入第5步的拒绝策略，也就是all reject。我们要做的就是在reject前，将自己的ipv6添加到ACCEPT的规则。看了一眼forwarding_rule，是个空的。所以有两个选择：delegate_forward下第1个位置插入自定义Chain，或者直接加到forwarding_rule。以直接加到forwarding_rule中为准：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加允许目标为[ip]的规则到 forwarding_rule</span></span><br><span class="line">ip6tables -A forwarding_rule -d device_ipv6 -j ACCEPT</span><br></pre></td></tr></table></figure><p>为什么要使用forwarding_rule，而不直接加在最外层呢？因为ip会变，我们说了是最小风险，所以当ip变更后，要删除旧的规则，这里如果有自定义Chain名称，可以很方便操作。因为forwarding_rule只包含你那一条，所以直接删除forwarding_rule里所有的配置项就可以了。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip6tables -F forwarding_rule</span><br></pre></td></tr></table></figure><p>如果你的forwarding_rule不为空(应该不会)，我们在添加规则的时候，也可以直接创建一个新Chain，加在delegate_forward下，forwarding_rule旁边就行了，总之就是一句话，让你的规则在reject前命中。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 最开始插入一条forwarding_rule_ip6</span></span><br><span class="line">ip6tables -I delegate_forward -j forwarding_rule_ip6</span><br><span class="line"><span class="comment"># 或者使用 ip6tables -A forwarding_rule -j forwarding_rule_ip6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将自己的ip添加到自定义规则中</span></span><br><span class="line">ip6tables -A forwarding_rule_ip6 -d device_ipv6 -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清空自定义规则</span></span><br><span class="line">ip6tables -F forwarding_rule_ip6</span><br></pre></td></tr></table></figure><h1 id="主机直接关闭ssh密码访问"><a href="#主机直接关闭ssh密码访问" class="headerlink" title="主机直接关闭ssh密码访问"></a>主机直接关闭ssh密码访问</h1><p>我本来就是想做个文件服务器，linux系统，既然路由上iptables限制了受访IP，再在开发板上加一道安全机制，限制外网使用ipv6通过密码来的方式进行ssh访问，这样一来，必须有访问需求的机器的key手动添加到服务器上才行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># /etc/ssh/sshd_config</span><br><span class="line"># 针对所有 IPv6 地址的配置 添加到文件末尾</span><br><span class="line">Match Address ::/0</span><br><span class="line">    PasswordAuthentication no</span><br><span class="line"></span><br><span class="line"># sudo systemctl restart sshd</span><br></pre></td></tr></table></figure><p>至于如何生成key添加到服务器，这里就不说了。</p><h1 id="ip变更后"><a href="#ip变更后" class="headerlink" title="ip变更后"></a>ip变更后</h1><p>做完以上配置，其实你的ipv6防火墙其实依然是开启状态，只不过加了一条目标ip的数据允许通过的规则。通过以上配置，已经可以达到理想的安全效果：只允许文件服务器被外网访问，外网不能通过ssh密码登录。但是nx54有一个问题，只要重新连接ipv6地址就会变化，所以需要将ip6tables命令加入定时任务中。我写过一个python脚本，通过定时触发，如果发现ip变动就给我email发一封邮件告诉我最新ip，在python中再添加如下加入清空自定义规则，加入允许访问IP规则。注意如果你自己新建了Chain，以你的名称为准。我是直接使用forwarding_rule。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 删除旧规则</span><br><span class="line">ip6tables -F forwarding_rule</span><br><span class="line"># 添加新的允许访问ip</span><br><span class="line">ip6tables -A forwarding_rule -d device_ipv6 -j ACCEPT</span><br></pre></td></tr></table></figure><p>具体流程如下：</p><ol><li>使用python获取最新非temporary的ip6地址。这一步对系统有兼容性，可能各种方式不一样。</li><li>对比上次获取的ipv6地址，比较是否一致，不一致说明有变化，需要更新，保存供下次比较。</li><li>参考我前面的blog，永久开启telnet，这一步网上有和第2步结合的脚本，但是使用curl发送的请求，那url又臭又长，不如参考我的一步到位。</li><li>使用python发送telnet，连接路由，输入密码，debugshell。</li><li>ip6tables -F forwarding_rule</li><li>ip6tables -A forwarding_rule -d your_device_ipv6 -j ACCEPT</li><li>加入crontab -e，半小时执行一次</li></ol><p>和朋友交流后，朋友说可以不采用email形式，钉钉、飞书这类办公软件有webhook，也就是当你ip变动后，你使用curl发一个网络请求，飞书就会给你发送消息。因为我基本不用飞书钉钉，所以就算了吧。当然了，也可以直接绑定域名，我其实已经做了AAAA解析了，但是懒得弄DDNS了(有个开源的程序叫DDNS-GO)，因为我外网连接机器这个并不是一个刚需且密集的事件，所以，需要的时候改ip地址就行了。</p><p>最后，非常感谢您的阅读。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;NX54终于更新固件了，新版本支持配置关闭ipv6防火墙，但是，防火墙关闭，相对而言风险也就上来了。其实最好的办法是，在防火墙上稍微开一个小口就行了，也就是，只允许目标地址是你指定IP的数据通过，今天就大概说说如何最小风险去处理这件事情。主要有以下两个操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ip6tables限制指定目标ip转发&lt;/li&gt;
&lt;li&gt;关闭要访问的服务器的ssh访问，windows主机可忽略&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="nx54" scheme="https://lefo.me/categories/nx54/"/>
    
    
    <category term="h3c" scheme="https://lefo.me/tags/h3c/"/>
    
    <category term="nx54" scheme="https://lefo.me/tags/nx54/"/>
    
  </entry>
  
  <entry>
    <title>如何构建一个pdfium.so</title>
    <link href="https://lefo.me/2024/05/12/build-pdfium/"/>
    <id>https://lefo.me/2024/05/12/build-pdfium/</id>
    <published>2024-05-12T06:50:01.000Z</published>
    <updated>2025-10-24T04:45:37.608Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>项目中接入了打开pdf文件的功能，使用的是<a href="https://github.com/barteksc/PdfiumAndroid/">https://github.com/barteksc/PdfiumAndroid/</a>。现在想升级一下pdfium库，旧库具体原因就不解释了，毕竟这个项目最后一个commit在6年前，当然，平常用来接入打开pdf也是没问题的。</p><h1 id="开源库"><a href="#开源库" class="headerlink" title="开源库"></a>开源库</h1><p>在google一通搜索，发现pdfium库包含两套，一套在aosp中，另一套在chromium中。</p><ul><li><a href="https://android.googlesource.com/platform/external/pdfium/">https://android.googlesource.com/platform/external/pdfium/</a></li><li><a href="https://pdfium.googlesource.com/pdfium/">https://pdfium.googlesource.com/pdfium/</a><br>两款代码应该差不多，aosp的构建使用Android.bp，版本要比pdfium版本的落后一些。再看PdfiumAndroid项目README，第一句就说Uses pdfium library from AOSP，使用的库应该也是aosp的库。</li></ul><h1 id="构建aosp版"><a href="#构建aosp版" class="headerlink" title="构建aosp版"></a>构建aosp版</h1><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ol><li>ubuntu 可以使用virtual box去装个虚拟机</li><li>200GB以上硬盘空间，清华会推荐你下载aosp-latest.tar再解压，光压缩包80G了，解压完我就把tar包删了</li></ol><h2 id="获取aosp源码"><a href="#获取aosp源码" class="headerlink" title="获取aosp源码"></a>获取aosp源码</h2><p>推荐使用清华镜像<a href="https://mirrors-i.tuna.tsinghua.edu.cn/help/AOSP/">https://mirrors-i.tuna.tsinghua.edu.cn/help/AOSP/</a>，可结合google的官方说明<a href="https://source.android.com/docs/setup?hl=zh-cn">https://source.android.com/docs/setup?hl=zh-cn</a>。具体指令就不介绍了，主要是repo sync费时，注意选好你想构建的build tag。</p><span id="more"></span><h2 id="Build"><a href="#Build" class="headerlink" title="Build"></a>Build</h2><p>使用aosp的编译比较简单，直接走aosp那一套就行，主要就是使用下列命令，不过也可以结合官方文档介绍，自行修改。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> aosp  <span class="comment"># 进到aosp根目录</span></span><br><span class="line">. build/envsetup.sh     <span class="comment"># 配置构建环境，这条命令会把一系列命令加到可执行环境中</span></span><br><span class="line">lunch armv8_eng         <span class="comment"># 配置要&lt;product_name&gt;-&lt;build_variant&gt;，我这里要的是arm64的</span></span><br><span class="line"><span class="built_in">cd</span> external/pdfium      <span class="comment"># go to pdfium directory</span></span><br><span class="line">mma                     <span class="comment"># build module and deps</span></span><br><span class="line"><span class="comment"># out/target/product/armv8/obj/SHARED_LIBRARIES/libpdfium_intermediates/libpdfium.so</span></span><br></pre></td></tr></table></figure><h1 id="构建chromium版本"><a href="#构建chromium版本" class="headerlink" title="构建chromium版本"></a>构建chromium版本</h1><h2 id="编好的库，直接拿来用"><a href="#编好的库，直接拿来用" class="headerlink" title="编好的库，直接拿来用"></a>编好的库，直接拿来用</h2><p><a href="https://github.com/bblanchon/pdfium-binaries">pdfium-binaries</a><br>这个项目是利用github action自动构建pdfium，其提供了所有版本的so，相当方便。另外想手动构建，有些要修改的内容，也可以参考这个项目中的patch。这个项目是我构建完以后才找到的，算是白忙活，不过也算是一点知识。</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>一开始我在网上搜了很多资料，都是讲如何构建这个版本的，所以我在aosp代码同步的时候，好顺带搞了搞这个，和aosp的mm就可以构建，这个是相当头疼啊。</p><ol><li>官方文档简单。官方只介绍了如何Build，但是没告诉你如何build安卓用的库。</li><li>网上内容复杂、老旧，对伸手党不友好。比如 <code>install-build-deps-android.sh</code>，我搜的所有资料，里面都有这条命令，但是，这个文件其实已经删除了。</li><li>没有镜像。可能是我没找到，反正代码是我全程开科技同步的。</li></ol><h2 id="准备-1"><a href="#准备-1" class="headerlink" title="准备"></a>准备</h2><ol><li>ubuntu。不确定mac行不行，我mac上试了一下，install-build-deps.sh提示我没有lsb-release，我就直接换ubuntu了</li><li>80GB硬盘。其实用不了，我虚拟机开了这么多。</li><li>上网要有科技，所有代码都在googlesource，建议有较好的网络。</li></ol><h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://chromium.googlesource.com/chromium/tools/depot_tools.git</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;<span class="variable">$PATH</span>:/path/to/depot_tools&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># get code</span></span><br><span class="line"><span class="built_in">mkdir</span> repo</span><br><span class="line"><span class="built_in">cd</span> repo</span><br><span class="line">gclient config --unmanaged https://pdfium.googlesource.com/pdfium.git</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;target_os = [ &#x27;android&#x27; ]&quot;</span> &gt;&gt; .gclient</span><br><span class="line">gclient <span class="built_in">sync</span></span><br><span class="line">gclient runhooks</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># setup build</span></span><br><span class="line"><span class="built_in">cd</span> pdfium</span><br><span class="line">./build/install-build-deps.sh --android</span><br><span class="line"></span><br><span class="line">gn args out</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="args"><a href="#args" class="headerlink" title="args"></a>args</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">target_os=&quot;android&quot;</span><br><span class="line">target_cpu=&quot;arm64&quot;</span><br><span class="line"></span><br><span class="line">use_goma = false</span><br><span class="line">pdf_bundle_freetype=true</span><br><span class="line">pdf_is_standalone=true</span><br><span class="line">is_component_build=false</span><br><span class="line">pdf_enable_xfa=false</span><br><span class="line">pdf_enable_v8=false</span><br><span class="line">pdf_use_skia = false</span><br><span class="line">use_cxx11_on_android=false</span><br><span class="line"></span><br><span class="line">is_debug=false</span><br><span class="line">is_official_build=true</span><br><span class="line">chrome_pgo_phase = 0</span><br></pre></td></tr></table></figure><h2 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h2><p>[Boto]<br>proxy &#x3D; example-host<br>proxy_port &#x3D; port number</p><p>save as your_file.boto<br>export NO_AUTH_BOTO_CONFIG&#x3D;&#x2F;path&#x2F;your_file.boto</p><h2 id="config"><a href="#config" class="headerlink" title="config"></a>config</h2><p>此节内容收集自互联网，有些内容并不适用，但第一条的FPDFSDK_EXPORTS是必须的。</p><ol><li>打开pdfium&#x2F;BUILD.gn 文件，找到 config(“pdfium_common_config”)，将以下配置：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">config(&quot;pdfium_common_config&quot;) &#123;</span><br><span class="line">  cflags = [ ]</span><br><span class="line">  ldflags = []</span><br><span class="line">  include_dirs = [ &quot;.&quot; ]</span><br><span class="line">  defines = [</span><br><span class="line">    &quot;PNG_PREFIX&quot;,</span><br><span class="line">    &quot;PNG_USE_READ_MACROS&quot;,</span><br><span class="line">    **&quot;FPDFSDK_EXPORTS&quot;**</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure></li></ol><ul><li>增加”-fvisibility&#x3D;default”到 cflags ，将符号的可见性设置为默认值。这意味着其他组件可以引用该符号，并且符号定义可以被另一个组件中的同名定义覆盖。</li><li>增加”-DNOCJK”到 cflags ，这将停止将字体嵌入到.so文件中并减小其大小。</li><li>增加“FPDFSDK_EXPORTS” 到 defines — 把符号表嵌入到共享库中。</li></ul><ol start="2"><li>在component(“pdfium”)前追加以下配置 -L&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libatomic貌似可以不加，因为之前是 -latomic，结果系统死活找不到  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">shared_library(&quot;pdfsdk&quot;) &#123;</span><br><span class="line">  deps = [&quot;:pdfium&quot;]</span><br><span class="line">  ldflags = [ &quot;-L/lib/x86_64-linux-gnu/libatomic&quot; ]</span><br><span class="line">  if (target_os == &quot;android&quot;) &#123;</span><br><span class="line">    configs -= [ &quot;//build/config/android:hide_all_but_jni_onload&quot; ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">component(&quot;pdfium&quot;) &#123;</span><br><span class="line">//…</span><br></pre></td></tr></table></figure></li></ol><h2 id="build"><a href="#build" class="headerlink" title="build"></a>build</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ninja -C out pdfsdk</span><br></pre></td></tr></table></figure><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><ol><li>指定commit同步代码：gclient sync –revision 837fe726e639f823a62ed4aa4abda45d40f3c803 </li><li>同步代码时要加的参数，因为我们只想要代码 并不想要history<br>  repo init –depth&#x3D;1 -u <a href="https://github.com/zawzaww/aosp-android.git-bandroid-8.1.0">https://github.com/zawzaww/aosp-android.git-bandroid-8.1.0</a><br>  repo sync  -f –force-sync –no-clone-bundle –no-tags -j$(nproc –all)</li><li>gclient也可以加上-no-history节省同步时间</li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/bblanchon/pdfium-binaries">pdfium-binaries</a><br><a href="https://i.lckiss.com/?p=5897">https://i.lckiss.com/?p=5897</a><br><a href="https://github.com/bblanchon/pdfium-binaries/blob/master/patches/shared_library.patch">https://github.com/bblanchon/pdfium-binaries/blob/master/patches/shared_library.patch</a><br><a href="https://groups.google.com/g/pdfium/c/-WdW5n0KZ-8">https://groups.google.com/g/pdfium/c/-WdW5n0KZ-8</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;项目中接入了打开pdf文件的功能，使用的是&lt;a href=&quot;https://github.com/barteksc/PdfiumAndroid/&quot;&gt;https://github.com/barteksc/PdfiumAndroid/&lt;/a&gt;。现在想升级一下pdfium库，旧库具体原因就不解释了，毕竟这个项目最后一个commit在6年前，当然，平常用来接入打开pdf也是没问题的。&lt;/p&gt;
&lt;h1 id=&quot;开源库&quot;&gt;&lt;a href=&quot;#开源库&quot; class=&quot;headerlink&quot; title=&quot;开源库&quot;&gt;&lt;/a&gt;开源库&lt;/h1&gt;&lt;p&gt;在google一通搜索，发现pdfium库包含两套，一套在aosp中，另一套在chromium中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://android.googlesource.com/platform/external/pdfium/&quot;&gt;https://android.googlesource.com/platform/external/pdfium/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://pdfium.googlesource.com/pdfium/&quot;&gt;https://pdfium.googlesource.com/pdfium/&lt;/a&gt;&lt;br&gt;两款代码应该差不多，aosp的构建使用Android.bp，版本要比pdfium版本的落后一些。再看PdfiumAndroid项目README，第一句就说Uses pdfium library from AOSP，使用的库应该也是aosp的库。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;构建aosp版&quot;&gt;&lt;a href=&quot;#构建aosp版&quot; class=&quot;headerlink&quot; title=&quot;构建aosp版&quot;&gt;&lt;/a&gt;构建aosp版&lt;/h1&gt;&lt;h2 id=&quot;准备&quot;&gt;&lt;a href=&quot;#准备&quot; class=&quot;headerlink&quot; title=&quot;准备&quot;&gt;&lt;/a&gt;准备&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;ubuntu 可以使用virtual box去装个虚拟机&lt;/li&gt;
&lt;li&gt;200GB以上硬盘空间，清华会推荐你下载aosp-latest.tar再解压，光压缩包80G了，解压完我就把tar包删了&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;获取aosp源码&quot;&gt;&lt;a href=&quot;#获取aosp源码&quot; class=&quot;headerlink&quot; title=&quot;获取aosp源码&quot;&gt;&lt;/a&gt;获取aosp源码&lt;/h2&gt;&lt;p&gt;推荐使用清华镜像&lt;a href=&quot;https://mirrors-i.tuna.tsinghua.edu.cn/help/AOSP/&quot;&gt;https://mirrors-i.tuna.tsinghua.edu.cn/help/AOSP/&lt;/a&gt;，可结合google的官方说明&lt;a href=&quot;https://source.android.com/docs/setup?hl=zh-cn&quot;&gt;https://source.android.com/docs/setup?hl=zh-cn&lt;/a&gt;。具体指令就不介绍了，主要是repo sync费时，注意选好你想构建的build tag。&lt;/p&gt;</summary>
    
    
    
    <category term="android开发" scheme="https://lefo.me/categories/android%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="android" scheme="https://lefo.me/tags/android/"/>
    
    <category term="pdfium" scheme="https://lefo.me/tags/pdfium/"/>
    
  </entry>
  
  <entry>
    <title>H3C NX54路由器如何永久开telnet，永久关闭ipv6防火墙</title>
    <link href="https://lefo.me/2024/02/20/nx54-telnet/"/>
    <id>https://lefo.me/2024/02/20/nx54-telnet/</id>
    <published>2024-02-20T03:17:40.000Z</published>
    <updated>2025-10-24T04:45:37.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前买了一台NX54路由器，结果这路由固件完全不给用户定制化的机会，研究如何保存ip6table的配置没有成功，但是成功保存了telnet开启配置，分享一下。这套固件的情况如下:</p><ol><li>默认开启ipv6防火墙，且关闭后，重启会失效，再次打开。</li><li>可以通过telnet连接路由，telnet配置也不保存，停电或者重启后失效。</li><li>根目录使用overlayfs做到了tmp下，是整个系统会恢复的主要原因。</li><li>提供了&#x2F;mnt目录保存数据，&#x2F;mnt&#x2F;bak&#x2F;startup.bak就是所有配置项。<span id="more"></span></li></ol><h1 id="关闭ipv6防火墙"><a href="#关闭ipv6防火墙" class="headerlink" title="关闭ipv6防火墙"></a>关闭ipv6防火墙</h1><ol><li>访问http:&#x2F;&#x2F;[ip]&#x2F;debug.asp</li><li>向下拉，找到telnet管理，勾选启动telnet，点旁边应用</li><li>在命令行执行如下命令，关闭ipv6防火墙<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">telnet &lt;路由ip&gt; 15000</span><br><span class="line"><span class="comment"># 输入密码</span></span><br><span class="line">&lt;your password&gt;</span><br><span class="line"><span class="comment"># &lt;H3C_NX54&gt;后输入 debugshell</span></span><br><span class="line">debugshell</span><br><span class="line">ip6tables -D FORWARD -j ACCEPT</span><br><span class="line">ip6tables -I FORWARD -j ACCEPT</span><br></pre></td></tr></table></figure></li></ol><h1 id="永久开telnet"><a href="#永久开telnet" class="headerlink" title="永久开telnet"></a>永久开telnet</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol><li>系统保存有一份配置文件，重启后会根据这份配置文件恢复配置。</li><li>配置文件格式如下 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;md5&gt; /var/run/.tmpcfg</span><br><span class="line">&lt;版本&gt;</span><br><span class="line">&lt;具体配置...&gt;</span><br></pre></td></tr></table></figure></li><li>其中md5用于校验整个文件，就是从版本号开始，后续所有配置计算得到的。</li><li>后续有个telnetenable&#x3D;的配置，但系统做了特殊设定，后台修改telnet并不会保存到配置中，导致telnet不能自动开，这里我们就需要手动修改配置文件。</li><li>修改后，替换md5摘要，整个配置就是一个有效配置。</li></ol><p>流程简单如下，移除第一行 -&gt; 计算md5 -&gt; md5重新加到第一行。</p><h1 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h1><h2 id="快速方法"><a href="#快速方法" class="headerlink" title="快速方法"></a><del>快速方法</del></h2><p>本方法只适合配置纯英文，不支持配置文件中有中文，如果失败，可以尝试下一节的手动处理方法。</p><ul><li><a href="/html/nx54config.html"><strong>NX54开启telnet配置生成器</strong></a>(输入所有配置文件内容，网页会帮你修改)</li><li><a href="/html/md5.html">md5在线计算</a>(注意本站会计算所有内容的md5，这里用不上，只做参考)<br>我搭建了一个网页，只要把路由的配置复制过来，就会生成开telnet的新配置。网页纯静态，不会向外发送你的任何配置信息，纯javascript本地运行的，这里教如何用网页转化配置。配置信息里有宽带密码账号，如果实在不放心我，下一个大标题的环节是纯手动改。</li></ul><ol><li>登录路由后台，设备管理 -&gt; 基本管理，备份，下载完成后，复制一份(防止万一需要初始化后恢复得再配置)。</li><li>用文本编辑器打开下载的文件</li><li>复制所有内容到 <a href="/html/nx54config.html">NX54开启telnet配置生成器</a> 左侧，在右侧会生成一份新配置。</li><li>点<code>COPY</code>，替换掉原配置文件内容，保存。</li><li>路由后台，选择文件，恢复。</li><li>等重启后，telnet就永久开了。接下来我们写一个shell，自动执行telnet并开ipv6，这些内容就自己找文心一言或者chatgpt生成吧。</li></ol><h2 id="配置文件带中文或者格式错误的手动处理方法"><a href="#配置文件带中文或者格式错误的手动处理方法" class="headerlink" title="配置文件带中文或者格式错误的手动处理方法"></a>配置文件带中文或者格式错误的手动处理方法</h2><p><strong>推荐，用上面的网页更快，但是配置中不得含有中文，否则生成的文件验证不通过。这里只是把流程纯手动，原理一样，但支持特殊符号、中文。</strong><br><strong><a href="/html/filemd5.html">文件md5计算</a></strong></p><ol><li>登录路由后台，设备管理 -&gt; 基本管理，备份，下载完成后，复制一份备份(防止万一需要初始化后恢复得再配置)。</li><li>打开如下 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5f0521762cfa7553351d4173706b4c99  /var/run/.tmpcfg</span><br><span class="line">NX54/NX54V100D011</span><br><span class="line">....</span><br></pre></td></tr></table></figure></li><li>找到<code>telnetenable=</code>，将&#x3D;后面的内容改为enable，保存。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@telnet</span><br><span class="line">#</span><br><span class="line">    telnetenable=enable</span><br></pre></td></tr></table></figure></li><li>删除第一行，只保留第二行<code>NX54/NX54V100D011</code>开始及后面内容，保存文件。</li><li>打开<a href="/html/filemd5.html">文件md5计算</a>计算，你也可以验证一下修改前的md5。</li><li>将生成的md5再次粘贴到第一行替换原md5(注意一定是小写) <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">新md5 /var/run/.tmpcfg</span><br><span class="line">NX54/NX54V100D011</span><br><span class="line">...</span><br><span class="line">@telnet</span><br><span class="line">#</span><br><span class="line">    telnetenable=enable</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li>去路由后台，备份那里找从文件中恢复设置信息，选择文件，点恢复。</li></ol><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><ol><li>最好不要直接全关ipv6防火墙，可以指定ip允许转发。</li><li>nx54分配的ip6地址不固定，所以如果指定ip后，每次需要移除旧的规则</li><li>通常我们都是让文件服务器或者NAS在外网访问，所以可以直接把命令写到nas上，一旦ip变动，则执行命令</li><li>具体iptable指令怎么调整，还是边学指令边问chatgpt吧，我这里就不弄了，我也没NAS，有个旧的arm板子，没怎么搭，去年看了一下快买不起硬盘了，硬盘现在价格逆天了。</li><li>全网首发，没找到怎么配置的方法，要转载请附上我的网址，给点流量。</li></ol><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>不能用中文是后来发现的，感谢新疆的大哥，提供了他的配置文件让我发现了问题。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;之前买了一台NX54路由器，结果这路由固件完全不给用户定制化的机会，研究如何保存ip6table的配置没有成功，但是成功保存了telnet开启配置，分享一下。这套固件的情况如下:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;默认开启ipv6防火墙，且关闭后，重启会失效，再次打开。&lt;/li&gt;
&lt;li&gt;可以通过telnet连接路由，telnet配置也不保存，停电或者重启后失效。&lt;/li&gt;
&lt;li&gt;根目录使用overlayfs做到了tmp下，是整个系统会恢复的主要原因。&lt;/li&gt;
&lt;li&gt;提供了&amp;#x2F;mnt目录保存数据，&amp;#x2F;mnt&amp;#x2F;bak&amp;#x2F;startup.bak就是所有配置项。</summary>
    
    
    
    <category term="nx54" scheme="https://lefo.me/categories/nx54/"/>
    
    
    <category term="h3c" scheme="https://lefo.me/tags/h3c/"/>
    
    <category term="nx54" scheme="https://lefo.me/tags/nx54/"/>
    
  </entry>
  
  <entry>
    <title>重学安卓之Jetpack</title>
    <link href="https://lefo.me/2024/01/30/jetpack/"/>
    <id>https://lefo.me/2024/01/30/jetpack/</id>
    <published>2024-01-30T14:07:12.000Z</published>
    <updated>2025-10-24T04:45:37.608Z</updated>
    
    <content type="html"><![CDATA[<h1 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h1><p>jetpack当时还没来得及用，整个项目就被砍掉了，这两年一直没有接触，最近好多岗位都要求会jetpack，这两年逐渐用的人越来越多，重学Android赶紧简单了解一下，做了一点整理，都是皮毛，供自己查笔记用吧，如果有一些知识点需要增加备注，随时修改。</p><h1 id="Navigation-用于fragment切换"><a href="#Navigation-用于fragment切换" class="headerlink" title="Navigation 用于fragment切换"></a>Navigation 用于fragment切换</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>可视化，可以as中可视化编辑</li><li>通过destination和action完成页面的导航</li><li>参数传递安全， safe args</li><li>支持deeplink，支持创建PendingIntent<span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回一个 PendingIntent</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> PendingIntent <span class="title function_">getPendingIntent</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Navigation.findNavController(requireActivity(), R.id.button)</span><br><span class="line">            .createDeepLink()</span><br><span class="line">            .setGraph(R.navigation.my_nav_graph)</span><br><span class="line">            .setDestination(R.id.detailFragment)</span><br><span class="line">            .createTaskStackBuilder()</span><br><span class="line">            .getPendingIntent(<span class="number">0</span>, PendingIntent.FLAG_IMMUTABLE);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="主要组件"><a href="#主要组件" class="headerlink" title="主要组件"></a>主要组件</h2><ol><li>Graph xml资源文件，包含所有页面和页面间的关系</li><li>Controller 用于完成Graph中的页面切换</li><li>NavHostFragment 特殊fragment容器</li><li>提供了NavigationUi控制各种bar的改变</li></ol><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤:"></a>操作步骤:</h2><ol><li>新建Android Resource File中的Graph文件，Resource type为Navigation，会在navigation目录下生成一个xml</li><li>将NavHostFragment添加到activity。&#96;&#96;，作为其它fragment的容器，defaultNaveHost&#x3D;true会自动处理返回键<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">fragment</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;android.navigation. fragment .NavHostFragment&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:defaultNaveHost</span>=<span class="string">&quot;true&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">app:navGraph</span>=<span class="string">&quot;@navigation/my_graph&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li>创建新的destination，其实就是将fragment添加到navigation，navigation会有一个startDesination</li><li>建立action，在可视编辑里是将一个和另一个连起来，xml中为fragment含有一个action标签，指向另一个fragment。</li><li>Navigation.findNavController(view).navigate(id)来完成导航</li></ol><h2 id="safe-args传递参数"><a href="#safe-args传递参数" class="headerlink" title="safe args传递参数"></a>safe args传递参数</h2><p>在fragment中添加参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 添加插件</span><br><span class="line">apply plugin: &#x27;androidx.navigation.safeargs&#x27;</span><br><span class="line"></span><br><span class="line">&lt;fragment&gt;</span><br><span class="line">    &lt;action/&gt;</span><br><span class="line">    &lt;argument </span><br><span class="line">        android:name=&quot;name&quot;</span><br><span class="line">        app:argType=&quot;string&quot;</span><br><span class="line">        android:defaultValue=&#x27;&quot;lefo&quot;&#x27;/&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>添加后，会生成对应的代码文件，就可以用Build创建对应的bundle了</p><h2 id="NavigationUi"><a href="#NavigationUi" class="headerlink" title="NavigationUi"></a>NavigationUi</h2><p>NavigationUI 提供了一些静态方法来处理 顶部应用栏 &#x2F; 抽屉式导航栏 &#x2F; 底部导航栏中 的界面导航, 统一管理 Fragment 页面切换相关的UI改变<br>CollapsingToolbarlayout、Toolbar、ActionBar</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 获取 NavController</span></span><br><span class="line">navController = Navigation.findNavController(<span class="built_in">this</span>, R.id.fragment)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建 AppBarConfiguration</span></span><br><span class="line">appBarConfiguration = AppBarConfiguration.Builder(navController.graph).build();</span><br><span class="line">NavigationUI.setupActionBarWithNavController(<span class="built_in">this</span>,navController,appBarConfiguration);</span><br></pre></td></tr></table></figure><h1 id="LifeCycle"><a href="#LifeCycle" class="headerlink" title="LifeCycle"></a>LifeCycle</h1><h2 id="LifecycleOwner和LifecycleObserver"><a href="#LifecycleOwner和LifecycleObserver" class="headerlink" title="LifecycleOwner和LifecycleObserver"></a>LifecycleOwner和LifecycleObserver</h2><p>实现LifecyclerObserver接口，将要在具体生命周期执行的方法使用@OnLifecycleEvent注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@OnLifecycleEvent</span> (Lifecycle.Event.ONRESUME) </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">onResumeEvent</span> <span class="params">()</span> &#123;</span><br><span class="line">    Log.d (TAG, <span class="string">&quot;onResumeEvent() &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">//在Activity中注册观察者</span></span><br><span class="line">getLifecycle().addObserver(myObserver);</span><br></pre></td></tr></table></figure><ul><li>LifecycleService，使用方式等于Service</li><li>ProcessLifecycleOwner 整个应用的生命周期 使用方法ProcessLifecycleOwner.get().getLifecycle()</li><li>LifecycleRegistry类，管理mObserverMap维护state和event</li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>通过在Activity中绑定一个空的fragment来实现监听Activity生命周期。</p><h1 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h1><p>使用ViewModelProvider创建一个ViewModel</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">constructor</span>(</span><br><span class="line">    owner: ViewModelStoreOwner</span><br><span class="line">) : <span class="keyword">this</span>(owner.viewModelStore, defaultFactory(owner), defaultCreationExtras(owner))</span><br></pre></td></tr></table></figure><p>通常使用ViewModelProvider</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NoteViewModelFactory</span>(<span class="keyword">private</span> <span class="keyword">val</span> repository: NoteRepository) : ViewModelProvider.Factory &#123;  </span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : ViewModel&gt;</span> <span class="title">create</span><span class="params">(modelClass: <span class="type">Class</span>&lt;<span class="type">T</span>&gt;)</span></span>: T &#123;  </span><br><span class="line"><span class="keyword">if</span> (modelClass.isAssignableFrom(NoteViewModel::<span class="keyword">class</span>.java)) &#123;  </span><br><span class="line"><span class="meta">@Suppress(<span class="string">&quot;UNCHECKED_CAST&quot;</span>)</span>  </span><br><span class="line"><span class="keyword">return</span> NoteViewModel(repository) <span class="keyword">as</span> T  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;Unknown ViewModel class&quot;</span>)  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> viewModel = ViewModelProvider(<span class="keyword">this</span>, NoteViewModelFactory(repository))[NoteViewModel::<span class="keyword">class</span>.java]</span><br></pre></td></tr></table></figure><p>基本原理如下</p><ol><li>ViewModelProvider接收参数ViewModelStoreOwner，参数的对象实现方法getViewModelStore</li><li>ViewModelStore提供一个HashMap&lt;String,ViewModel&gt;</li></ol><p>为什么ViewModel在横竖屏切换时，不会被销毁，其实是因为ViewModel是保存在ViewModelStore中的，而在感知到Destory的生命周期时，会判断isChangingConfigurations，如果为否，才会进入getViewModelStore().clear();</p><h1 id="LiveData"><a href="#LiveData" class="headerlink" title="LiveData"></a>LiveData</h1><p>LiveData的作用是ViewModel在数据发生变化时通知页面</p><ul><li>实际上就是一个观察者模式的数据容器，当数据改变时，通知UI刷新；</li><li>能感知activity fragment组件生命周期，</li><li>通常和viewModel一起使用，<code>LiveData&lt;T&gt;</code>作为ViewModel的一个成员变量</li><li>liveData.observe()注册一个对数据的观察</li><li>observeForever使用后一定要用removeObserver方法停止观察</li></ul><h1 id="DataBinding"><a href="#DataBinding" class="headerlink" title="DataBinding"></a>DataBinding</h1><h2 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h2><ul><li>DataBinding结合ViewModel是常用的做法</li><li>向include的二级页面传递数据</li><li>BaseObservable和ObservableField支持多个控件互相绑定数据<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- activity_main.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">            <span class="attr">name</span>=<span class="string">&quot;user&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">type</span>=<span class="string">&quot;com.example.User&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">RelativeLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;@&#123;user.name&#125;&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;Click&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:onClick</span>=<span class="string">&quot;@&#123;() -&gt; user.onButtonClick()&#125;&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : AppCompatActivity() &#123;</span><br><span class="line"></span><br><span class="line">    override fun <span class="title function_">onCreate</span><span class="params">(savedInstanceState: Bundle?)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 DataBindingUtil 设置布局文件和数据绑定</span></span><br><span class="line">        val binding: ActivityMainBinding = DataBindingUtil.setContentView(<span class="built_in">this</span>, R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 User 对象</span></span><br><span class="line">        <span class="type">val</span> <span class="variable">user</span> <span class="operator">=</span> User(<span class="string">&quot;John Doe&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 User 对象绑定到布局中的 user 变量</span></span><br><span class="line">        binding.user = user</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置点击事件</span></span><br><span class="line">        binding.button.setOnClickListener &#123;</span><br><span class="line">            user.onButtonClick()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">include</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">layout</span>=<span class="string">&quot;@layout/layout2&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:user</span>=<span class="string">&quot;@&#123;user&#125;&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--在2级页面这么写--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">        <span class="attr">name</span>=<span class="string">&quot;user&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">type</span>=<span class="string">&quot;com.example.User&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="自定义BindAdapter"><a href="#自定义BindAdapter" class="headerlink" title="自定义BindAdapter"></a>自定义BindAdapter</h2><p>还可以增加一个参数作为旧值，但此时必须先写旧值</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> CustomBindingAdapters &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BindingAdapter(<span class="string">&quot;imageUrl&quot;</span>)</span></span><br><span class="line">    <span class="meta">@JvmStatic</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">loadImage</span><span class="params">(imageView: <span class="type">ImageView</span>, url: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 使用 Glide 加载图片</span></span><br><span class="line">        Glide.with(imageView.context)</span><br><span class="line">            .load(url)</span><br><span class="line">            .into(imageView)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BindingAdapter(<span class="string">&quot;visibility&quot;</span>)</span></span><br><span class="line">    <span class="meta">@JvmStatic</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setVisibility</span><span class="params">(view: <span class="type">View</span>, isVisible: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 设置 View 的可见性</span></span><br><span class="line">        view.visibility = <span class="keyword">if</span> (isVisible) View.VISIBLE <span class="keyword">else</span> View.GONE</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/imageView&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:imageUrl</span>=<span class="string">&quot;@&#123;viewModel.imageUrl&#125;&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">View</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/customView&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:visibility</span>=<span class="string">&quot;@&#123;viewModel.isVisible&#125;&quot;</span> /&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="ViewBinding"><a href="#ViewBinding" class="headerlink" title="ViewBinding"></a>ViewBinding</h1><p>减少findviewbyid，简单举例一下</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 View Binding</span></span><br><span class="line"><span class="keyword">val</span> binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">setContentView(binding.root)</span><br></pre></td></tr></table></figure><h1 id="Room"><a href="#Room" class="headerlink" title="Room"></a>Room</h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity(tableName = <span class="string">&quot;user_table&quot;</span>)</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">User</span>(</span><br><span class="line">    <span class="meta">@PrimaryKey(autoGenerate = true)</span></span><br><span class="line">    <span class="keyword">val</span> id: <span class="built_in">Long</span> = <span class="number">0</span>,</span><br><span class="line">    <span class="keyword">val</span> name: String,</span><br><span class="line">    <span class="keyword">val</span> email: String</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dao</span></span><br><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="meta">@Query(<span class="string">&quot;SELECT * FROM user_table&quot;</span>)</span></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getAllUsers</span><span class="params">()</span></span>: List&lt;User&gt;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert(onConflict = OnConflictStrategy.REPLACE)</span></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">insertUser</span><span class="params">(user: <span class="type">User</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @Database(entities = [User::class], version = 1, exportSchema = false)</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AppDatabase</span> : <span class="type">RoomDatabase</span>() &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">userDao</span><span class="params">()</span></span>: UserDao</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>数据库，使用起来和之前的注解框架差不多，可以配合LiveData和ViewModel实现数据的刷新。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UserRepository</span>(<span class="keyword">private</span> <span class="keyword">val</span> userDao: UserDao) &#123;</span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUsersFromNetwork</span><span class="params">()</span></span>: List&lt;User&gt; &#123;</span><br><span class="line">        <span class="comment">// 从网络获取数据的逻辑</span></span><br><span class="line">        <span class="keyword">val</span> networkData = <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将数据存储到数据库</span></span><br><span class="line">        userDao.insertUser(networkData)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> networkData</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getAllUsers</span><span class="params">()</span></span>: List&lt;User&gt; &#123;</span><br><span class="line">        <span class="comment">// 从数据库获取数据的逻辑</span></span><br><span class="line">        <span class="keyword">return</span> userDao.getAllUsers()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ViewModel中使用Repository</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyViewModel</span>(<span class="keyword">private</span> <span class="keyword">val</span> userRepository: UserRepository) : ViewModel() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _users = MutableLiveData&lt;List&lt;User&gt;&gt;()</span><br><span class="line">    <span class="keyword">val</span> users: LiveData&lt;List&lt;User&gt;&gt; <span class="keyword">get</span>() = _users</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">fetchData</span><span class="params">()</span></span> &#123;</span><br><span class="line">        viewModelScope.launch &#123;</span><br><span class="line">            <span class="comment">// 从网络获取数据并更新数据库</span></span><br><span class="line">            userRepository.getUsersFromNetwork()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从数据库获取数据并更新 LiveData</span></span><br><span class="line">            _users.value = userRepository.getAllUsers()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Paging"><a href="#Paging" class="headerlink" title="Paging"></a>Paging</h1><p>Paging还是看官方文档更合适，网上搜的信息Paging2和Paging3内容混乱，这里我也不整理了，特别是使用RemoteMediator去同时接入 db + network 的方案。<br><strong>paging库3.0变化较大，放个<a href="%5Bhttps://developer.android.google.cn/topic/libraries/architecture/paging/v3-overview?hl=zh-cn%5D">官方链接</a></strong><br><strong><a href="https://github.com/android/architecture-components-samples/blob/main/PagingWithNetworkSample/">官方DEMO</a></strong></p><ol><li>PagingDataAdapter，首先RecyclerView的Adapter需要继承这个类，此外，您也可以使用随附的 AsyncPagingDataDiffer 组件构建自己的自定义适配器</li><li>Pager 基于 PagingSource 对象和 PagingConfig 配置对象来构造在响应式流中公开的 PagingData 实例。</li><li>PagingSource，数据载入，有一个load方法需要实现</li><li>PagingData 用于存放分页数据快照的容器。它会查询 PagingSource 对象并存储结果。</li><li>RemoteMediator 处理分层数据源。</li></ol><blockquote><p>Paging 2 中的 PageKeyedDataSource、PositionalDataSource 和 ItemKeyedDataSource 都合并到了 Paging 3 中的 PagingSource API 中。所有旧版 API 类中的加载方法都合并到了 PagingSource 中的单个 load() 方法中。这样可以减少代码重复，因为在旧版 API 类的实现中，各种加载方法之间的很多逻辑通常是相同的。<br>在 Paging 3 中，所有加载方法参数被一个 LoadParams 密封类替代，该类中包含了每个加载类型所对应的子类。如果需要区分 load() 方法中的加载类型，请检查传入了 LoadParams 的哪个子类：LoadParams.Refresh、LoadParams.Prepend 还是 LoadParams.Append。</p></blockquote><ol><li><del>BoundaryCallback</del>弃用了，使用RemoteMediator。在分页数据耗尽时，Paging 库会触发 RemoteMediator 以从网络源加载新数据。RemoteMediator 会将新数据存储在本地数据库中，因此无需在 ViewModel 中使用内存缓存。最后，PagingSource 会使自身失效，而 Pager 会创建一个新实例以从数据库中加载新数据。</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@OptIn(ExperimentalPagingApi::class)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExampleRemoteMediator</span>(</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> query: String,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> database: RoomDb,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> networkService: ExampleBackendService</span><br><span class="line">) : RemoteMediator&lt;<span class="built_in">Int</span>, User&gt;() &#123;</span><br><span class="line">  <span class="keyword">val</span> userDao = database.userDao()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">load</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    loadType: <span class="type">LoadType</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    state: <span class="type">PagingState</span>&lt;<span class="type">Int</span>, User&gt;</span></span></span><br><span class="line"><span class="params"><span class="function">  )</span></span>: MediatorResult &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="WorkManager"><a href="#WorkManager" class="headerlink" title="WorkManager"></a>WorkManager</h1><p>最低兼容api 14，在api 23以上使用JobScheduler，在api 23以下使用AlarmManager</p><ol><li>创建Worker<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyWorker</span>(context: Context, workerParams: WorkerParameters) : Worker(context, workerParams) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doWork</span><span class="params">()</span></span>: Result &#123;</span><br><span class="line">        <span class="comment">// 后台任务逻辑</span></span><br><span class="line">        Timber.d(<span class="string">&quot;Performing long running task in MyWorker&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回任务执行结果</span></span><br><span class="line">        <span class="keyword">return</span> Result.success()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>设置约束条件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import androidx.work.Constraints</span><br><span class="line">import androidx.work.NetworkType</span><br><span class="line"></span><br><span class="line">val constraints = Constraints.Builder()</span><br><span class="line">    .setRequiredNetworkType(NetworkType.CONNECTED)</span><br><span class="line">    .setRequiresCharging(true)</span><br><span class="line">    .build()</span><br></pre></td></tr></table></figure></li><li>创建请求<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一次性工作请求</span></span><br><span class="line"><span class="keyword">val</span> oneTimeRequest = OneTimeWorkRequest.Builder(MyWorker::<span class="keyword">class</span>.java)</span><br><span class="line">    .setConstraints(constraints)</span><br><span class="line">    .build()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 周期性工作请求</span></span><br><span class="line"><span class="keyword">val</span> periodicRequest = PeriodicWorkRequest.Builder(MyWorker::<span class="keyword">class</span>.java, <span class="number">24</span>, TimeUnit.HOURS)</span><br><span class="line">    .setConstraints(constraints)</span><br><span class="line">    .build()</span><br></pre></td></tr></table></figure></li><li>加入队列<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 将一次性工作请求加入队列</span><br><span class="line">WorkManager.getInstance(context).enqueue(oneTimeRequest)</span><br><span class="line"></span><br><span class="line">// 将周期性工作请求加入队列</span><br><span class="line">WorkManager.getInstance(context).enqueue(periodicRequest)</span><br></pre></td></tr></table></figure>WorkManager还支持链式任务，观察任务状态，传递参数。</li></ol><ul><li>链式: 在加入队列时使用beginWith(oneTimeRequest).then(periodicRequest)，还可以combine…then…</li><li>观察任务状态: WorkManager.getWorkInfosXXX，可以通过tag,id,worker对象查看任务状态，还能获取对应的LiveData，通过LiveData就能在任务状态变化时收到通知</li><li>传参: Data类</li></ul><h1 id="Hilt"><a href="#Hilt" class="headerlink" title="Hilt"></a>Hilt</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 在应用模块的 build.gradle 文件中</span><br><span class="line">implementation &quot;com.google.dagger:hilt-android:2.38.1&quot;</span><br><span class="line">kapt &quot;com.google.dagger:hilt-android-compiler:2.38.1&quot;</span><br><span class="line"></span><br><span class="line">// 如果使用了ViewModel，还需要添加以下依赖</span><br><span class="line">implementation &quot;androidx.hilt:hilt-lifecycle-viewmodel:1.0.0-alpha03&quot;</span><br><span class="line">kapt &quot;androidx.hilt:hilt-compiler:1.0.0-alpha03&quot;</span><br></pre></td></tr></table></figure><ol><li>在 Application 类中启用 Hilt： 在你的 Application 类中使用 @HiltAndroidApp 注解启用 Hilt。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@HiltAndroidApp</span><br><span class="line">class MyApplication : Application()</span><br></pre></td></tr></table></figure></li><li>配置依赖注入： 使用 @Inject 注解标记需要注入的依赖，同时使用 @HiltViewModel 注解标记需要注入的 ViewModel。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class MyRepository @Inject constructor() &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@HiltViewModel</span><br><span class="line">class MyViewModel @Inject constructor(private val repository: MyRepository) : ViewModel() &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>在 Activity 或 Fragment 中使用 Hilt 注入： 在需要注入依赖的 Activity 或 Fragment 中，使用 @AndroidEntryPoint 注解启用 Hilt，并使用 @Inject 注解标记需要注入的字段。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@AndroidEntryPoint</span><br><span class="line">class MyActivity : AppCompatActivity() &#123;</span><br><span class="line"></span><br><span class="line">    @Inject</span><br><span class="line">    lateinit var viewModel: MyViewModel</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>在 Module 中配置依赖： 如果需要自定义依赖注入的配置，可以创建一个 Dagger Module，并在其上使用 @InstallIn 注解指定作用范围。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Module</span><br><span class="line">@InstallIn(ApplicationComponent::class)</span><br><span class="line">object MyModule &#123;</span><br><span class="line"></span><br><span class="line">    @Provides</span><br><span class="line">    fun provideMyRepository(): MyRepository &#123;</span><br><span class="line">        return MyRepository()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="DataStore"><a href="#DataStore" class="headerlink" title="DataStore"></a>DataStore</h1><ul><li>用于存储较小的数据集，分为Preferences DataStore和Proto DataStore，可以代替SP，可以轻松迁移数据。</li><li><a href="https://developer.android.com/topic/libraries/architecture/datastore?hl=zh-cn">官方介绍</a></li></ul><h2 id="Preferences-DataStore"><a href="#Preferences-DataStore" class="headerlink" title="Preferences DataStore"></a>Preferences DataStore</h2><ul><li>读取用flow</li><li>写入用edit<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建dataStore context.createDataStore</span></span><br><span class="line"><span class="comment">// 使用委托创建dataStore</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> USER_PREFERENCES_NAME = <span class="string">&quot;user_preferences&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> Context.dataStore <span class="keyword">by</span> preferencesDataStore(</span><br><span class="line">    name = USER_PREFERENCES_NAME,</span><br><span class="line">    produceMigrations = &#123; context -&gt;</span><br><span class="line">        <span class="comment">// Since we&#x27;re migrating from SharedPreferences, add a migration based on the</span></span><br><span class="line">        <span class="comment">// SharedPreferences name</span></span><br><span class="line">        listOf(SharedPreferencesMigration(context, USER_PREFERENCES_NAME))</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><p>当 DataStore 从文件读取数据时，如果读取数据期间出现错误，系统会抛出 IOExceptions。我们可以通过以下方式处理这些事务：在 map() 之前使用 catch() Flow 运算符，并且在抛出的异常是 IOException 时发出 emptyPreferences()。如果出现其他类型的异常，最好重新抛出该异常。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> userPreferencesFlow: Flow&lt;UserPreferences&gt; = dataStore.<span class="keyword">data</span></span><br><span class="line">    .<span class="keyword">catch</span> &#123; exception -&gt;</span><br><span class="line">        <span class="comment">// dataStore.data throws an IOException when an error is encountered when reading data</span></span><br><span class="line">        <span class="keyword">if</span> (exception <span class="keyword">is</span> IOException) &#123;</span><br><span class="line">            emit(emptyPreferences())</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> exception</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.map &#123; preferences -&gt;</span><br><span class="line">        <span class="comment">// Get our show completed value, defaulting to false if not set:</span></span><br><span class="line">        <span class="keyword">val</span> showCompleted = preferences[PreferencesKeys.SHOW_COMPLETED]?: <span class="literal">false</span></span><br><span class="line">        UserPreferences(showCompleted)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">updateShowCompleted</span><span class="params">(showCompleted: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">    dataStore.edit &#123; preferences -&gt;</span><br><span class="line">        preferences[PreferencesKeys.SHOW_COMPLETED] = showCompleted</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以使用扩展函数asLiveData转换flow为LiveData</span></span><br><span class="line">userPreferencesFlow.asLiveData().observe(viewLifecycleOwner,&#123; &#125;)</span><br></pre></td></tr></table></figure><h2 id="Proto-DataStore"><a href="#Proto-DataStore" class="headerlink" title="Proto DataStore"></a>Proto DataStore</h2><ol><li>区别于之前的Preferences DataStore的读取方式.map{ preferences-&gt; { } }</li><li>写入方式使用updateData(){ preferences-&gt; {…}}<br>生成pb对象和类<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line">option java_package = <span class="string">&quot;com.codelab.android.datastore&quot;</span>;</span><br><span class="line">option java_multiple_files = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">message UserPreferences &#123;</span><br><span class="line">  <span class="comment">// filter for showing / hiding completed tasks</span></span><br><span class="line">  bool show_completed = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>创建UserPreferencesSerializer<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> UserPreferencesSerializer : Serializer&lt;UserPreferences&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> defaultValue: UserPreferences = UserPreferences.getDefaultInstance()</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">readFrom</span><span class="params">(input: <span class="type">InputStream</span>)</span></span>: UserPreferences &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> UserPreferences.parseFrom(input)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (exception: InvalidProtocolBufferException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> CorruptionException(<span class="string">&quot;Cannot read proto.&quot;</span>, exception)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">writeTo</span><span class="params">(t: <span class="type">UserPreferences</span>, output: <span class="type">OutputStream</span>)</span></span> = t.writeTo(output)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>创建DataStore<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> USER_PREFERENCES_NAME = <span class="string">&quot;user_preferences&quot;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> DATA_STORE_FILE_NAME = <span class="string">&quot;user_prefs.pb&quot;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> SORT_ORDER_KEY = <span class="string">&quot;sort_order&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> Context.userPreferencesStore: DataStore&lt;UserPreferences&gt; <span class="keyword">by</span> dataStore(</span><br><span class="line">    fileName = DATA_STORE_FILE_NAME,</span><br><span class="line">    serializer = UserPreferencesSerializer</span><br><span class="line">)</span><br></pre></td></tr></table></figure>读取数据<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> TAG: String = <span class="string">&quot;UserPreferencesRepo&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> userPreferencesFlow: Flow&lt;UserPreferences&gt; = dataStore.<span class="keyword">data</span></span><br><span class="line">    .<span class="keyword">catch</span> &#123; exception -&gt;</span><br><span class="line">        <span class="comment">// dataStore.data throws an IOException when an error is encountered when reading data</span></span><br><span class="line">        <span class="keyword">if</span> (exception <span class="keyword">is</span> IOException) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">&quot;Error reading sort order preferences.&quot;</span>, exception)</span><br><span class="line">            emit(UserPreferences.getDefaultInstance())</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> exception</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>写入数据<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">updateShowCompleted</span><span class="params">(completed: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">    dataStore.updateData &#123; preferences -&gt;</span><br><span class="line">        preferences.toBuilder().setShowCompleted(completed).build()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h1&gt;&lt;p&gt;jetpack当时还没来得及用，整个项目就被砍掉了，这两年一直没有接触，最近好多岗位都要求会jetpack，这两年逐渐用的人越来越多，重学Android赶紧简单了解一下，做了一点整理，都是皮毛，供自己查笔记用吧，如果有一些知识点需要增加备注，随时修改。&lt;/p&gt;
&lt;h1 id=&quot;Navigation-用于fragment切换&quot;&gt;&lt;a href=&quot;#Navigation-用于fragment切换&quot; class=&quot;headerlink&quot; title=&quot;Navigation 用于fragment切换&quot;&gt;&lt;/a&gt;Navigation 用于fragment切换&lt;/h1&gt;&lt;h2 id=&quot;优点&quot;&gt;&lt;a href=&quot;#优点&quot; class=&quot;headerlink&quot; title=&quot;优点&quot;&gt;&lt;/a&gt;优点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;可视化，可以as中可视化编辑&lt;/li&gt;
&lt;li&gt;通过destination和action完成页面的导航&lt;/li&gt;
&lt;li&gt;参数传递安全， safe args&lt;/li&gt;
&lt;li&gt;支持deeplink，支持创建PendingIntent</summary>
    
    
    
    <category term="android" scheme="https://lefo.me/categories/android/"/>
    
    
    <category term="android" scheme="https://lefo.me/tags/android/"/>
    
    <category term="重学android" scheme="https://lefo.me/tags/%E9%87%8D%E5%AD%A6android/"/>
    
    <category term="Jetpack" scheme="https://lefo.me/tags/Jetpack/"/>
    
  </entry>
  
  <entry>
    <title>第一次尝试frida</title>
    <link href="https://lefo.me/2023/10/06/frida/"/>
    <id>https://lefo.me/2023/10/06/frida/</id>
    <published>2023-10-06T15:31:26.000Z</published>
    <updated>2025-10-24T04:45:37.608Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>大概半个月前，群里的一个小伙伴问，谁能把某电商APP的订单列表导出到电脑，有个私活，报个价。其实我对这种稍微有点了解，无非是抓包，破解。但通常App的网络请求会有一套签名验证机制，所以要想模拟出整套请求流程，也算比较复杂。和群里的讨论后，觉得用hook做合适，但群里和我一样，都是安卓开发，没有逆向工程师，首先想到的是xposed。</p><h1 id="xposed太重"><a href="#xposed太重" class="headerlink" title="xposed太重"></a>xposed太重</h1><p>我之前倒是写过xposed，xposed缺点有两个，第一就是环境复杂，你得安装xposed环境才可以，目前都是通过virtual xposed来使用。再就是插件一但有修改，就得重启手机。不过这也带来了一个有点就是持久化，只要装进去，就一直存在。那有没有更轻量级的工具可以达到这种效果，后来在网上找到了frida。(这也好几年了，我居然不知道)</p><span id="more"></span><h1 id="Frida"><a href="#Frida" class="headerlink" title="Frida"></a>Frida</h1><p>官网<br><a href="https://github.com/frida/frida/releases">https://github.com/frida/frida/releases</a><br><a href="https://frida.re/">https://frida.re</a></p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>Frida分为客户端(电脑) + 服务端(手机端)。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pip3 install frida</span><br><span class="line">pip3 install frida-tools</span><br><span class="line"><span class="comment"># 安装完成后运行，查看是否安装成功，有进程输出说明成功</span></span><br><span class="line">frida-ps -U</span><br></pre></td></tr></table></figure><p>下载服务端程序到手机(模拟器)，必须有root权限。下载时注意选择你对应平台的frida-server</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">adb push frida-server /data/local/tmp/</span><br><span class="line">adb shell</span><br><span class="line">su</span><br><span class="line"><span class="built_in">chmod</span> 777 /data/local/tmp/frida-server</span><br><span class="line">/data/local/tmp/frida-server</span><br></pre></td></tr></table></figure><h2 id="注入js，hook"><a href="#注入js，hook" class="headerlink" title="注入js，hook"></a>注入js，hook</h2><p>举一个hook okhttp的例子，okhttp的响应信息都打印出来。在电脑上新建一个test.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.js  hook okhttp 因为okhttp的response只能消费一次，为了不影响默认的程序，将buffer复制一份</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">get_http</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> <span class="title class_">RealCall</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;okhttp3.RealCall&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> <span class="title class_">Buffer</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;okio.Buffer&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> <span class="title class_">ResponseBody</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;okhttp3.ResponseBody&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="title class_">RealCall</span>.<span class="property">getResponseWithInterceptorChain</span>.<span class="title function_">overload</span>().<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> response =  <span class="variable language_">this</span>.<span class="title function_">getResponseWithInterceptorChain</span>();</span><br><span class="line">            <span class="keyword">var</span> responseBody = response.<span class="title function_">body</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> buffer = <span class="title class_">Buffer</span>.$new();</span><br><span class="line">            responseBody.<span class="title function_">source</span>().<span class="title function_">readAll</span>(buffer);</span><br><span class="line">            <span class="keyword">var</span> responseBodyString = buffer.<span class="title function_">readUtf8</span>();</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;HTTP Request -&gt; &quot;</span> + <span class="variable language_">this</span>.<span class="title function_">request</span>().<span class="title function_">url</span>().<span class="title function_">toString</span>());</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;HTTP Response -&gt; &quot;</span> + responseBodyString);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> builder = response.<span class="title function_">newBuilder</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> newResponse = builder.<span class="title function_">body</span>(<span class="title class_">ResponseBody</span>.<span class="title function_">create</span>(responseBody.<span class="title function_">contentType</span>(), responseBodyString)).<span class="title function_">build</span>();</span><br><span class="line">            <span class="keyword">return</span> newResponse;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动服务端后，在客户端(电脑)上运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># U是USB F是当前app，这里用-n也不会重启(frida-ps查到的名字)，用-f 包名 会重启app</span><br><span class="line">frida -UF test.js</span><br><span class="line"># 运行后，会进入frida，我们还需要输入具体js函数，比如get_http()</span><br><span class="line">get_http()</span><br></pre></td></tr></table></figure><h2 id="关于frida的语法，简单介绍一个常用的，剩下的上官网查。"><a href="#关于frida的语法，简单介绍一个常用的，剩下的上官网查。" class="headerlink" title="关于frida的语法，简单介绍一个常用的，剩下的上官网查。"></a>关于frida的语法，简单介绍一个常用的，剩下的上官网查。</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var Class = Java.use(&quot;class name&quot;);</span><br><span class="line">Class.method.overload(&quot;param class name&quot;).implementation = function( param) &#123;</span><br><span class="line">    # param.xxxx</span><br><span class="line">    # console.log(&quot;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;大概半个月前，群里的一个小伙伴问，谁能把某电商APP的订单列表导出到电脑，有个私活，报个价。其实我对这种稍微有点了解，无非是抓包，破解。但通常App的网络请求会有一套签名验证机制，所以要想模拟出整套请求流程，也算比较复杂。和群里的讨论后，觉得用hook做合适，但群里和我一样，都是安卓开发，没有逆向工程师，首先想到的是xposed。&lt;/p&gt;
&lt;h1 id=&quot;xposed太重&quot;&gt;&lt;a href=&quot;#xposed太重&quot; class=&quot;headerlink&quot; title=&quot;xposed太重&quot;&gt;&lt;/a&gt;xposed太重&lt;/h1&gt;&lt;p&gt;我之前倒是写过xposed，xposed缺点有两个，第一就是环境复杂，你得安装xposed环境才可以，目前都是通过virtual xposed来使用。再就是插件一但有修改，就得重启手机。不过这也带来了一个有点就是持久化，只要装进去，就一直存在。那有没有更轻量级的工具可以达到这种效果，后来在网上找到了frida。(这也好几年了，我居然不知道)&lt;/p&gt;</summary>
    
    
    
    <category term="android" scheme="https://lefo.me/categories/android/"/>
    
    
    <category term="android" scheme="https://lefo.me/tags/android/"/>
    
    <category term="frida" scheme="https://lefo.me/tags/frida/"/>
    
  </entry>
  
  <entry>
    <title>重学安卓之kotlin协程</title>
    <link href="https://lefo.me/2023/08/08/kotlin-coroutine/"/>
    <id>https://lefo.me/2023/08/08/kotlin-coroutine/</id>
    <published>2023-08-07T18:03:24.000Z</published>
    <updated>2025-10-24T04:45:37.608Z</updated>
    
    <content type="html"><![CDATA[<h1 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h1><p>因为2021年开始做C++，之前的项目还没来得及怎么用kotlin，就直接被爸爸宣布死刑了。所以目前找工作等于需要再学一次kotlin，特别是协程，之前几乎没有了解。买了本书，再加上网上的各种文章，整理一点笔记出来。如果有和我差不多的，可以看一看</p><p>协程，协程可以理解为某种自由调度的任务，主要是对函数挂起，恢复。听起来像线程的唤醒，本质上和线程没什么关系。使用协程，我们可以以单线程的方式写多线程的代码，同时还能节省线程资源，并且能方便处理异常信息，返回结果等。我们给函数前面加一个<code>suspend</code>关键字，就变成一个挂起函数，可以在函数内操作协程的挂起和恢复。其中部分内容有重复，不必理会。主要参考资料&lt;深入理解Kotlin协程&gt;，算是一个简单的笔记整理。</p><h1 id="协程的API"><a href="#协程的API" class="headerlink" title="协程的API"></a>协程的API</h1><h2 id="什么是挂起"><a href="#什么是挂起" class="headerlink" title="什么是挂起"></a>什么是挂起</h2><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">fun download(url: String) &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line">suspend fun bitmapSuspendable(url: String): Bitmap = </span><br><span class="line">    // 挂起协程 下载完成后，调用resume</span><br><span class="line">    suspendCoroutine&lt;Bitmap&gt; &#123; continuation -&gt; </span><br><span class="line">        thread &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                continuation.resume(download(url))</span><br><span class="line">            &#125; catch (e: Exception) &#123;</span><br><span class="line">                continuation.resumeWithException(e)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">suspend fun main() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        var bitmap = bitmapSuspendable(&quot;url1&quot;)</span><br><span class="line">    &#125; catch ( e: Exception) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的代码使用suspendCoroutine函数包装download，协程结束后，使用resume返回bitmap结果。当然，Kotlin 协程提供了更方便的库函数来处理挂起操作，不需要我们来实现。</p><ul><li><strong>suspend</strong>关键字，被suspend关键字修饰的函数叫挂起函数。suspend函数只能被协程或者suspend函数调用。</li><li><strong>suspendCoroutine<T></strong> 用于挂起协程的函数，返回值类型作为挂起函数的返回值，也就是泛型参数T的实参Bitmap，这个函数除了确实返回值类型外，还能帮我们拿到一个Continuation实例，负责保存和恢复挂起状态。</li><li><strong>resume</strong>: 恢复协程 resumeWithException:将exception携带恢复协程</li><li><strong>resumeWith</strong>: 用于恢复协程执行，并提供一个 Result 对象作为协程的结果，该对象可以包含成功的返回值或异常。</li><li><strong>resumeWithException</strong>: 恢复一个协程，并传递一个异常。一般无需显式调用，因为协程库会自动处理协程的取消和异常传播。</li></ul><h2 id="系统提供的函数"><a href="#系统提供的函数" class="headerlink" title="系统提供的函数"></a>系统提供的函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">suspend fun load(time: Int): String &#123;</span><br><span class="line">    delay(1000)</span><br><span class="line">    return &quot;result $time&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main = runBlocking &#123;</span><br><span class="line">    val load1 = async &#123; load(1) &#125;</span><br><span class="line">    val load2 = async &#123; load(2) &#125;</span><br><span class="line">    // 等待获取结果</span><br><span class="line">    load1.await()</span><br><span class="line">    load2.await()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，runBlocking用来创建一个阻塞的主协程，runBlocking中的代码会阻塞当前线程，直到所有协程都执行完成，这样可以不改变代码结构的情况下使用挂起函数。还有下面这些常用的函数。通常我们使用<code>launch</code>和<code>withContext</code>多一些，具体使用在后面有，这里就不放代码了。</p><ul><li>async 启动异步协程，可以通过调用await来等待获取异步结果</li><li>launch: 启动一个新协程，新协程和当前协程并行运行。但是它不会等待新协程的完成，继续执行后续代码。该函数会返回一个Job对象，可以使用该对象来控制、取消、等待该协协程的执行。</li><li>withContext: 用于在指定的上下文中执行协程代码块，并等待代码块执行完成。与 launch 不同，withContext 挂起当前协程。常用于在协程中切换到指定的调度器上执行代码。</li><li>produce: 创建一个生产者协程，用于生成序列化的值。生产者协程可以使用 send 函数将值发送到管道中，并使用 receive 函数从管道中接收值。</li><li>actor: 创建一个带有状态的协程，用于执行并发操作并保持状态。actor 协程可以接收并处理发送到它的消息，允许在协程之间共享和交换数据。</li><li>supervisorScope: 创建一个作用域，其中的子协程的失败不会影响其他子协程。当一个子协程失败时，supervisorScope 中的其他子协程仍然可以继续执行。</li><li>repeat: 创建一个协程，重复执行指定的代码块，类似于循环。可以使用 delay 函数来控制重复执行的间隔。</li><li>select: 用于在多个挂起操作之间进行选择，类似于 select 语句。可以在一个 select 代码块中等待多个挂起函数的结果，当其中一个操作准备就绪时，select 将执行相应的代码块。</li></ul><h2 id="协程怎么创建的"><a href="#协程怎么创建的" class="headerlink" title="协程怎么创建的"></a>协程怎么创建的</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">val continuation = suspend &#123;</span><br><span class="line">    println(&quot;In Coroutine&quot;)</span><br><span class="line">    5</span><br><span class="line">&#125;.createCoroutine(object: Continuation&lt;Int&gt;) &#123;</span><br><span class="line">    override fun resumeWith(result: Result&lt;Int&gt;) &#123;</span><br><span class="line">        println(&quot;Coroutine End: $result&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看createCoroutine声明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun &lt;T&gt; (suspend () -&gt; T).createCoroutine(</span><br><span class="line">    completion:Continuation&lt;T&gt;</span><br><span class="line">): Continuation&lt;Unit&gt;</span><br></pre></td></tr></table></figure><ul><li>suspend () -&gt; T是被suspend修饰的挂起函数，可以称作是协程体。</li><li>completion是协程完成后的回调</li><li>返回值是一个Continuation，用于触发协程的启动，<strong>其实就是包了几层马甲的协程体</strong></li></ul><p>作用域 scope，可以在协程体中直接调用作用域对象的函数。挂起函数加了RestrictsSuspension注解就不能调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">fun &lt;R, T&gt; (suspend R.() -&gt; T).createCoroutine(</span><br><span class="line">    receiver R,</span><br><span class="line">    completion: Continuation&lt;T&gt;</span><br><span class="line">): Continuation&lt;Unit&gt;</span><br><span class="line"></span><br><span class="line">// 封装一个启动协程的函数</span><br><span class="line">fun &lt;R, T&gt; launchCoroutine(receiver: R, block: suspend R.() -&gt; T) &#123;</span><br><span class="line">    block.startCoroutine(receiver, object : Continuation&lt;T&gt;) &#123;</span><br><span class="line">        override fun resumeWith(result: Result&lt;Int&gt;) &#123;</span><br><span class="line">        println(&quot;Coroutine End: $result&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 启动带有Receiver的协程</span><br><span class="line">class ProducerScope&lt;T&gt; &#123;</span><br><span class="line">    suspend fun produce(value: T) &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line">fun callLaunchCoroutine() &#123;</span><br><span class="line">    launchCoroutine(ProducerScope&lt;Init&gt;()) &#123;</span><br><span class="line">        produce(1024)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>挂起函数就是普通函数的参数中多了一个Continuation实例。任何一个挂起函数或者协程体都有一个Continuation实例，所以挂起函数一定要运行在挂起函数或者其它协程体中。</strong> </p><h2 id="协程scope的概念"><a href="#协程scope的概念" class="headerlink" title="协程scope的概念"></a>协程scope的概念</h2><p>CoroutineScope，CoroutineScope可以理解为协程的作用域，会跟踪它使用 launch 或 async 创建的所有协程。您可以随时调用 scope.cancel() 以取消正在进行的工作（即正在运行的协程）。在 Android 中，某些 KTX 库为某些生命周期类提供自己的 CoroutineScope。例如，ViewModel 有 viewModelScope，Lifecycle 有 lifecycleScope。不过，与调度程序不同，CoroutineScope 不运行协程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class ExampleClass &#123;</span><br><span class="line"></span><br><span class="line">    // Job and Dispatcher are combined into a CoroutineContext which</span><br><span class="line">    // will be discussed shortly</span><br><span class="line">    val scope = CoroutineScope(Job() + Dispatchers.Main)</span><br><span class="line"></span><br><span class="line">    fun exampleMethod() &#123;</span><br><span class="line">        // Starts a new coroutine within the scope</span><br><span class="line">        scope.launch &#123;</span><br><span class="line">            // New coroutine that can call suspend functions</span><br><span class="line">            fetchDocs()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun cleanUp() &#123;</span><br><span class="line">        // Cancel the scope to cancel ongoing coroutines work</span><br><span class="line">        scope.cancel()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用launch 或 async 创建的协程会返回一个Job。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class ExampleClass &#123;</span><br><span class="line">    ...</span><br><span class="line">    fun exampleMethod() &#123;</span><br><span class="line">        // Handle to the coroutine, you can control its lifecycle</span><br><span class="line">        val job = scope.launch &#123;</span><br><span class="line">            // New coroutine</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (...) &#123;</span><br><span class="line">            // Cancel the coroutine started above, this doesn&#x27;t affect the scope</span><br><span class="line">            // this coroutine was launched in</span><br><span class="line">            job.cancel()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Job有一个函数叫<code>join()</code>，它会阻塞当前协程，直到目标协程执行完成为止。</p><h1 id="Android中的协程"><a href="#Android中的协程" class="headerlink" title="Android中的协程"></a>Android中的协程</h1><h2 id="常用启动协程的方式"><a href="#常用启动协程的方式" class="headerlink" title="常用启动协程的方式"></a>常用启动协程的方式</h2><ul><li>launch 启动新协和而不将结果返回调用方。</li><li>async 启动新协程，并允许使用一个名为await的挂起函数返回结果。</li><li>withContext 挂起当前协程，本身就是一个挂起函数，作用等价于async{}.await()</li></ul><p>通常应该用launch，只有另一个协程内时，或在挂起函数内且正在执行并行分解时，才使用 async。在suspend函数启动的所有协程，都必须在函数返回结果前停止。可以使用await()&#x2F;awaitAll()保证协程在函数返回结果前完成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">suspend fun fetchTwoDocs() =</span><br><span class="line">    coroutineScope &#123;</span><br><span class="line">        val deferredOne = async &#123; fetchDoc(1) &#125;</span><br><span class="line">        val deferredTwo = async &#123; fetchDoc(2) &#125;</span><br><span class="line">        deferredOne.await()</span><br><span class="line">        deferredTwo.await()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">suspend fun fetchTwoDocs() =        // called on any Dispatcher (any thread, possibly Main)</span><br><span class="line">    coroutineScope &#123;</span><br><span class="line">        val deferreds = listOf(     // fetch two docs at the same time</span><br><span class="line">            async &#123; fetchDoc(1) &#125;,  // async returns a result for the first doc</span><br><span class="line">            async &#123; fetchDoc(2) &#125;   // async returns a result for the second doc</span><br><span class="line">        )</span><br><span class="line">        deferreds.awaitAll()        // use awaitAll to wait for both network requests</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h2><ol><li>Dispatchers.Default: 用于执行 CPU 密集型的计算任务，比如对数据进行处理、转换等。它使用共享的线程池，并且适用于不会阻塞线程的操作。</li><li>Dispatchers.Main: 用于在主线程中执行操作，比如更新 UI、处理用户交互等。在 Android 中，它与主线程关联，因此适用于 UI 操作。</li><li>Dispatchers.Unconfined: 不受限制的调度器，它会在协程恢复执行时，继续使用调用者线程。但是，一旦恢复执行的代码开始执行挂起操作，调度器会切换到其他线程。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">button.setOnclickListener &#123;</span><br><span class="line">    GlobalScope.launch(Dispatchers.Main) &#123;</span><br><span class="line">        // ..</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>另外还有一个<code>MainScop()</code>函数，注意要在关闭的时候调用cancel<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//activity</span><br><span class="line">private val mainScope by lazy &#123; MainScop() &#125;</span><br><span class="line"></span><br><span class="line">button.setOnClickListener &#123;</span><br><span class="line">    mainScope.launch &#123;</span><br><span class="line">        // ui线程</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// onDestory 注意要调用cancel</span><br><span class="line">mainScope.cancel()</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><ul><li>lifecycleScope.launch {}</li><li>viewModelScope.launch {}</li></ul><h2 id="常见函数"><a href="#常见函数" class="headerlink" title="常见函数"></a>常见函数</h2><ul><li>withTimeout(1000) : 超时取消</li></ul><h2 id="实用技巧"><a href="#实用技巧" class="headerlink" title="实用技巧"></a>实用技巧</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// </span><br><span class="line">suspend fun a() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">scope.launch(Dispatchers.IO) &#123; </span><br><span class="line">    //...</span><br><span class="line">    a()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上方的代码存在的问题是，因为要想调用a()，每次必须显式在子线程中调用。可以将a改进，使用withContext封装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 这种方式可以确保a的调用者不用关注在哪个线程中执行</span><br><span class="line">supsend fun a() : Result &#123;</span><br><span class="line">    return withContext(Dispatchers.IO) &#123;</span><br><span class="line">        //...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改进后，要想调用a，必须使用协程。这种方式可以确保a的调用者不用关注在哪个线程中执行。</p><h1 id="Channel-Flow"><a href="#Channel-Flow" class="headerlink" title="Channel &amp; Flow"></a>Channel &amp; Flow</h1><h2 id="Channel-（热流）"><a href="#Channel-（热流）" class="headerlink" title="Channel （热流）"></a>Channel （热流）</h2><p>Channel相当于生产者消费者，<strong>先生产再消费</strong>，在协程中间建立一个缓存区。produce函数可以构建一个生产者协程，也可以在协程中只创建Channel。推荐用produce channel，不要用actor(obsolete)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 相关代码</span><br><span class="line">val channel = produce &#123;</span><br><span class="line">    //...</span><br><span class="line">    send(it)</span><br><span class="line">&#125;</span><br><span class="line">val channel = actor&lt;Int&gt; &#123;</span><br><span class="line">    //...</span><br><span class="line">    val element = receiver()</span><br><span class="line">&#125;</span><br><span class="line">channel.send()</span><br><span class="line">channel.receive()</span><br></pre></td></tr></table></figure><p>Channel的内部实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public fun &lt;E&gt; Channel(capacity: Int = RENDEZVOUS): Channel&lt;E&gt; =</span><br><span class="line">  when (capcity) &#123;</span><br><span class="line">    // 容量为1，send后，不调用receiver就一直挂起</span><br><span class="line">    RENDEZVOUS -&gt; RendezvousChannel()</span><br><span class="line">    // 容量无限</span><br><span class="line">    UNLIMITED -&gt; LinkedListChannel()</span><br><span class="line">    // 只保留最后一个</span><br><span class="line">    CONFLATED -&gt; ConflatedChannel()</span><br><span class="line">    // 指定大小</span><br><span class="line">    else -&gt; ArrayChannel(capacity)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>Channel是需要关闭的，produce方法会在协程结束后自去关闭对应的_channel，所以不用担心。需要注意的是，<strong>一旦调用close，它的isClosoedForSend方法会立即返回true，但是因为里面还有元素，isClosedForReceiver要等全处理完才返回true</strong></p><p><strong>BroadcastChannel</strong> 顾名思义，广播所以receiver都会收到。需要注意，必须有一个订阅者，不然数据会被丢弃。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val broadcastChannel = BroadcastChannel&lt;Int&gt;(5)</span><br><span class="line">val receiverChannel = broadcastChannel.openSubscription()</span><br><span class="line">receiverChannle.receiver()</span><br><span class="line">receiverChannle.cancel()</span><br></pre></td></tr></table></figure><p>普通Channel也可以通过调用<code>broadcast()</code>函数来转换成broadcast</p><h2 id="Flow-（冷流）"><a href="#Flow-（冷流）" class="headerlink" title="Flow （冷流）"></a>Flow （冷流）</h2><p>flow <strong>不消费不生产</strong>，不会立即执行flow的内容，会在collect的时候，才去执行。消费者协程cancel()后，flow会跟着结束(没有缓冲队列，区别channel)</p><p>flow的末端函数都是suspend函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">val flow = flow &#123;</span><br><span class="line">    val data = &quot;DATA&quot;</span><br><span class="line">    emit(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">launch &#123;</span><br><span class="line">    flow.collect &#123; data -&gt;</span><br><span class="line">        //...</span><br><span class="line">        cancel()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>不同的消费者协程不共享flow，如下列代码，flow中的代码会被多次执行。(每个消费者拥有独立的生产者)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">repeat(2) &#123;ci -&gt;</span><br><span class="line">    launch &#123;</span><br><span class="line">        flow.collect &#123; data -&gt;</span><br><span class="line">            //...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果在不同线程操作，可以使用flow.flowOn(Dispatchers.Main)进行上下文切换。</li><li>如果要在Flow完成时执行逻辑，可以使用onCompletion，相当于try catch的finally</li></ul><p>** 背压问题 ** 生产者生产太快，消费者跟不上。解决：</p><ol><li>调用flow.buffer() 加入缓存</li><li>调用flow.conflate() 新数据替换旧数据</li><li>调用使用flow.conllectLatest() 和 conllect的区别是，它不会直接使用新数据覆盖老数据，会依序处理，但如果前一个没处理完的话会被取消。</li></ol><h2 id="channelFlow"><a href="#channelFlow" class="headerlink" title="channelFlow"></a>channelFlow</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">channelFlow，使flow具体channel的特性</span><br><span class="line">val flow = channelFlow &#123;</span><br><span class="line">    withContext(Dispatcher.IO) &#123;</span><br><span class="line">        send(&quot;DATA&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="callbackFlow"><a href="#callbackFlow" class="headerlink" title="callbackFlow"></a>callbackFlow</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">val result = trySend(&quot;DATA&quot;)</span><br><span class="line">result.onSuccess &#123;</span><br><span class="line"></span><br><span class="line">&#125;.onFailure &#123;</span><br><span class="line"></span><br><span class="line">&#125;.onClosed &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">协程cancel后，会调用awaitClose</span><br><span class="line">awaitClose &#123;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">launch &#123;</span><br><span class="line">    flow.collect &#123;</span><br><span class="line">        //...</span><br><span class="line">        cancel()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="冷流-热流"><a href="#冷流-热流" class="headerlink" title="冷流&amp;热流"></a>冷流&amp;热流</h2><table><thead><tr><th>项目</th><th>冷流</th><th>热流</th></tr></thead><tbody><tr><td>生产时间机</td><td>一旦创建立即生产</td><td>需要时生产</td></tr><tr><td>多个消费者</td><td>消费者按顺序获取</td><td>每个消费者有独立的生产线路</td></tr><tr><td>生命周期</td><td>生产者消费者无关系</td><td>生产者消费者生命周期一致</td></tr></tbody></table><h2 id="SharedFlow-StateFlow-热流"><a href="#SharedFlow-StateFlow-热流" class="headerlink" title="SharedFlow &amp; StateFlow 热流"></a>SharedFlow &amp; StateFlow 热流</h2><p>flow.ShareIn()方法，传递3个参数：scope协程域<br>flow.StateIn()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flow &#123;...&#125;.stateIn(scope)</span><br><span class="line">//类似</span><br><span class="line">flow &#123;...&#125;.shareIn(scope,</span><br><span class="line">    stared = SharingStarted.Eagerly,</span><br><span class="line">    replay = 1</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>stateFlow要和repeatOnLifecycle一起使用防止热流在view的无效生命周期更新</p><h1 id="协程并发问题"><a href="#协程并发问题" class="headerlink" title="协程并发问题"></a>协程并发问题</h1><h2 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h2><p>和线程锁类似，不过不会阻塞线程，只是挂起等待锁的释放</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var count = 0</span><br><span class="line">val mutex = mutex()</span><br><span class="line">List(1000) &#123;</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        mutext.withLock &#123;</span><br><span class="line">            count ++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.joinAll()</span><br></pre></td></tr></table></figure><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>信号量，信号量可以有多个，当参数为1时，效果等价于Mutex</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">val semaphore = Semaphore(1)</span><br><span class="line">List(1000) &#123;</span><br><span class="line">    GlobalScopre.launch &#123;</span><br><span class="line">        semaphore.withPermit &#123;</span><br><span class="line">            count++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.joinAll()</span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>要注意避免访问外部状态，只能基于参数做运算，再通过返回值提供结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val count = 0</span><br><span class="line">val result = count + List(1000) &#123;</span><br><span class="line">    GlobalScope.async &#123;1&#125;</span><br><span class="line">&#125;.map &#123;</span><br><span class="line">    it.await()</span><br><span class="line">&#125;.sum()</span><br></pre></td></tr></table></figure><p> GlobalScope.async 创建了一个由 1000 个协程组成的集合，每个协程都会返回整数值 1。然后通过 map 函数等待所有协程的执行结果，并将结果求和。最终的结果会赋值给变量 result。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h1&gt;&lt;p&gt;因为2021年开始做C++，之前的项目还没来得及怎么用kotlin，就直接被爸爸宣布死刑了。所以目前找工作等于需要再学一次kotlin，特别是协程，之前几乎没有了解。买了本书，再加上网上的各种文章，整理一点笔记出来。如果有和我差不多的，可以看一看&lt;/p&gt;
&lt;p&gt;协程，协程可以理解为某种自由调度的任务，主要是对函数挂起，恢复。听起来像线程的唤醒，本质上和线程没什么关系。使用协程，我们可以以单线程的方式写多线程的代码，同时还能节省线程资源，并且能方便处理异常信息，返回结果等。我们给函数前面加一个&lt;code&gt;suspend&lt;/code&gt;关键字，就变成一个挂起函数，可以在函数内操作协程的挂起和恢复。其中部分内容有重复，不必理会。主要参考资料&amp;lt;深入理解Kotlin协程&amp;gt;，算是一个简单的笔记整理。&lt;/p&gt;
&lt;h1 id=&quot;协程的API&quot;&gt;&lt;a href=&quot;#协程的API&quot; class=&quot;headerlink&quot; title=&quot;协程的API&quot;&gt;&lt;/a&gt;协程的API&lt;/h1&gt;&lt;h2 id=&quot;什么是挂起&quot;&gt;&lt;a href=&quot;#什么是挂起&quot; class=&quot;headerlink&quot; title=&quot;什么是挂起&quot;&gt;&lt;/a&gt;什么是挂起&lt;/h2&gt;</summary>
    
    
    
    <category term="kotlin" scheme="https://lefo.me/categories/kotlin/"/>
    
    
    <category term="重学android" scheme="https://lefo.me/tags/%E9%87%8D%E5%AD%A6android/"/>
    
    <category term="kotlin" scheme="https://lefo.me/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>C++学习笔记</title>
    <link href="https://lefo.me/2021/08/13/cpp-note/"/>
    <id>https://lefo.me/2021/08/13/cpp-note/</id>
    <published>2021-08-13T05:28:05.000Z</published>
    <updated>2025-10-24T04:45:37.608Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第2节"><a href="#第2节" class="headerlink" title="第2节"></a>第2节</h1><p>防卫式声明，防止重复include引起的问题(guard)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//complex.h</span><br><span class="line">#ifndef _COMPLEX_</span><br><span class="line">#def _COMPLEX_</span><br><span class="line">...</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><span id="more"></span><h1 id="第3节"><a href="#第3节" class="headerlink" title="第3节"></a>第3节</h1><p>inline 内联函数</p><p>构造函数 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public:</span><br><span class="line">    complex(double r = 0,double i = 0)</span><br><span class="line">        :re(r),im(i)</span><br><span class="line">        //上面的默认值是推荐用法</span><br><span class="line">    &#123;&#125;</span><br><span class="line">...</span><br><span class="line">complex c1(2,1)</span><br><span class="line">complex c2</span><br><span class="line">complex* c3 = new complex(4)</span><br></pre></td></tr></table></figure><h1 id="第4节"><a href="#第4节" class="headerlink" title="第4节"></a>第4节</h1><p>数据是private</p><p>参数、返回值尽可能拿引用传递：除了返回值需要新创建对象的情况</p><p>能加const的函数尽量加const</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type function () const &#123; return result&#125;</span><br></pre></td></tr></table></figure><h1 id="第6节"><a href="#第6节" class="headerlink" title="第6节"></a>第6节</h1><p>操作符重载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">complex::operator += (const complex&amp; r)&#123;</span><br><span class="line">return </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//ostream不加const </span><br><span class="line">ostream&amp; operator &lt;&lt; (ostream&amp; os, const complex&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">return os &lt;&lt; &#x27;(&#x27; &lt;&lt; real(x) &lt;&lt; &#x27;,&#x27; &lt;&lt; imag(x) &lt;&lt; &#x27;)&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第7节"><a href="#第7节" class="headerlink" title="第7节"></a>第7节</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class String</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">String(const char* cstr = 0);</span><br><span class="line">String(const String&amp; str);</span><br><span class="line">String&amp; operator =(const String&amp; str);</span><br><span class="line">~String()</span><br><span class="line">char* get_c_str() const &#123;return mdata&#125;;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">char* m_data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拷贝构造(浅拷贝会内存溢出)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inline String::String(const String&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">m_data = new char[ strlen(str.m_data) + 1];</span><br><span class="line">strcpy(m_data,str.m_data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拷贝赋值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">inline String::operator = (const string&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">//不使用这个自我赋值判断，会刹掉自己</span><br><span class="line">if(this == &amp;str)</span><br><span class="line">retrun *this</span><br><span class="line">  delete[] m_data;</span><br><span class="line">m_data = new char[ strlen(str.m_data) + 1];</span><br><span class="line">strcpy(m_data,str.m_data)</span><br><span class="line">return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第8节"><a href="#第8节" class="headerlink" title="第8节"></a>第8节</h1><p>new :先分配内存，再调用ctor</p><p>delete:先调用析构函数，再释放内存</p><p>array new 要搭配 array delete使用</p><h1 id="第15-16-17-18节"><a href="#第15-16-17-18节" class="headerlink" title="第15 16 17 18节"></a>第15 16 17 18节</h1><p>转换函数 ，构造方法也可以当转换函数转，比如4转为4&#x2F;1</p><p>explicit :加在构造方法前面，表示必须得显示调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Fraction</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">  Fraction(int num,int den=1)</span><br><span class="line">   : m_numberator(m), m_denominato &#123;&#125;</span><br><span class="line">  operator double() const&#123;</span><br><span class="line">    return (double)(a/b)</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line">Fraction f(3,5)</span><br><span class="line">double d=4+5</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Fraction operator+(const Fraction&amp; f)&#123;</span><br><span class="line">return Fraction(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pointer like classes 智能指针</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">class shared_ptr</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">T&amp; operator*() const</span><br><span class="line">&#123; return *px; &#125;</span><br><span class="line">T* operator-&gt;() const</span><br><span class="line">&#123; return px; &#125;</span><br><span class="line"></span><br><span class="line">shared_ptr(T* P) :px(p)&#123;&#125;</span><br><span class="line">private:</span><br><span class="line">T* px;</span><br><span class="line">long* pn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Function-like classes</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class T&gt;</span><br><span class="line">struct identity&#123;</span><br><span class="line">const T&amp;</span><br><span class="line">operator()(const T&amp; x) const &#123;return x;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第19-25节"><a href="#第19-25节" class="headerlink" title="第19 - 25节"></a>第19 - 25节</h1><p>namespace  可以代码放一个文件进行，然后用namespace分割</p><p>类模板、函数模板、成员模板，函数模板使用时无需指定类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class T1,class T2&gt;</span><br><span class="line">struct pair&#123;</span><br><span class="line">T1 first;</span><br><span class="line">T2 second;</span><br><span class="line">pair():first(T1()),second(T2);</span><br><span class="line">pair(const T1&amp; a,const T2&amp; b):</span><br><span class="line">   first(a),second(b)&#123;&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class U1,class U2&gt;</span><br><span class="line">pair(const pair&lt;U1,U2&gt;&amp; p):</span><br><span class="line">   first(p.first),second(p.second)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模板特化，可以理解为限定类的模板特殊设计</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template &lt;&gt;</span><br><span class="line">struct hash&lt;char&gt;&#123;</span><br><span class="line">size_t operator()(char x) const&#123;</span><br><span class="line">return x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模板模板参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T,</span><br><span class="line">          template &lt;typename T&gt;&gt;</span><br><span class="line">              class Container</span><br><span class="line">              &gt;</span><br><span class="line">class XCLs&#123;</span><br><span class="line">private:</span><br><span class="line">     Container&lt;T&gt;c;</span><br><span class="line">public:</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">using Lst = list&lt;T, allocator&lt;T&gt;&gt;;</span><br><span class="line"></span><br><span class="line">//XCLs&lt;string, list&gt; mylst1; 错的</span><br><span class="line">XCLs&lt;string,Lst&gt; mylst2;</span><br></pre></td></tr></table></figure><p>模板偏特化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T,class Alloc=...&gt;</span><br><span class="line">class vector&lt;bool,Alloc&gt;&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">//指针</span><br><span class="line">class C&lt;T*&gt;&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第27节"><a href="#第27节" class="headerlink" title="第27节"></a>第27节</h1><p>auto 关键字 必须得让编译器能推出你的变量是什么</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list&lt;string&gt; c;</span><br><span class="line">...</span><br><span class="line">list&lt;string&gt;::iterator ite;</span><br><span class="line">ite = find(c.begin(),c.end,target);</span><br><span class="line">auto ite = find(c.begin(),c.end,target);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (auto eleme : vec)&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (auto&amp; eleme : vec)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第28节"><a href="#第28节" class="headerlink" title="第28节"></a>第28节</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int x = 0;</span><br><span class="line">int* p = &amp;x;</span><br><span class="line">int&amp; r = x;//r代表x 现在r, x 都是0</span><br><span class="line">int x2 = 5;</span><br><span class="line">//等于把5赋值给x</span><br><span class="line">r = x2;//r 不能重新代表其它物体，现在r x都是5</span><br><span class="line">int&amp; r2 = r;//r2 x 都是5</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">double image(const double&amp; im)&#123;...&#125;</span><br><span class="line">double image(const double im)&#123;...&#125;</span><br><span class="line">//不能共存 Ambiguity</span><br></pre></td></tr></table></figure><p>const属于签名的一部分，有const和没有const可以并存</p><h1 id="第30-31节"><a href="#第30-31节" class="headerlink" title="第30-31节"></a>第30-31节</h1><p>vptr和vtbl</p><p>先通过指针 找到函数表再找到第n个 再调用</p><p>(*(p-&gt;vptr)[n])(p);</p><p>(* p-&gt;vptr[n] )(p);</p><p>编译器三个条件就会动态绑定</p><p>1.指针调用 2.向上转型 3.虚函数</p><p>(*(this -&gt; vptr)[n])(this);</p><h1 id="第33-38节"><a href="#第33-38节" class="headerlink" title="第33-38节"></a>第33-38节</h1><p>当成员函数的const和 non-const版本同时存在，const object只会调用const版本，non-const object只会调用non-const版本</p><p>new 和 delete可以重载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inline void* operator new(size_t size)</span><br><span class="line">&#123; return myAlloc(size);&#125;</span><br><span class="line">inline void operator delete(void* ptr)</span><br><span class="line">&#123; myfree(ptr);&#125;</span><br></pre></td></tr></table></figure><p>可以对成员的new &#x2F;delete 做重载，写到类里</p><p>如果想使用globals</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Foo* pf = ::new Foo;</span><br><span class="line">::delete pf</span><br><span class="line">//将使用全局的new 和delete</span><br></pre></td></tr></table></figure><p>数组在内存中的size是countsize + unit * count </p><p>我们可以重载class member operator new()，写多个版本，每个声明必须有独特的参数列，且第一个必须是size_t，其余参数是new指定的placement arguments为初值。小括号内的便是placement arguments</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Foo* pf = new(300,&#x27;c&#x27;) Foo;</span><br></pre></td></tr></table></figure><p>可以重载class member operator delete()，写出多个版本，调不到，大师说老版本的能调到，在new异常的时候</p><p>operator new()在标准库的用处，多分配一些内存</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;第2节&quot;&gt;&lt;a href=&quot;#第2节&quot; class=&quot;headerlink&quot; title=&quot;第2节&quot;&gt;&lt;/a&gt;第2节&lt;/h1&gt;&lt;p&gt;防卫式声明，防止重复include引起的问题(guard)&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//complex.h&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#ifndef _COMPLEX_&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#def _COMPLEX_&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#endif&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="c++" scheme="https://lefo.me/categories/c/"/>
    
    
    <category term="c++" scheme="https://lefo.me/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>记一次编译安卓模拟器镜像</title>
    <link href="https://lefo.me/2021/08/11/make-image/"/>
    <id>https://lefo.me/2021/08/11/make-image/</id>
    <published>2021-08-11T13:49:03.000Z</published>
    <updated>2025-10-24T04:45:37.608Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>想要编译一个自己的framework，用来在系统api中插入自己的代码，监听一下应用的行为，比如获取imei，获取网络。最直接的想法就是，修改安卓源码，直接编译出一个系统镜像，给模拟器使用。</p><p>准备：</p><ol><li><p>因为之前编译过android.jar，所以源码环境还有，直接开工，或者看以前编译的文章有讲。</p></li><li><p>修改代码，比如找到TelephonyManager.java，在getDeviceId()中插入自己的代码。</p></li></ol><span id="more"></span><h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">source ./build/envsetup.sh</span><br><span class="line">lunch sdk_phone_x86-userdebug</span><br><span class="line">make update-api</span><br><span class="line">make -j16 sdk sdk_repo</span><br></pre></td></tr></table></figure><p><em>注意：下面的部分是官方写的，如何编译一个sdk给别人也能用。但我没有成功，make sdk_repo的时候，失败了</em></p><p>在<code>host/linux-x86/sdk/sdk_phone_x86</code>下找到两个文件</p><ul><li><code>sdk-repo-linux-system-images-eng.[username].zip</code></li><li><code>repo-sys-img.xml</code></li></ul><p>将这两个文件放到你服务器可访问的位置，记下url。再将xml中的<code>&lt;sdk:url&gt;</code>替换成zip的url。</p><p>在SDK Manager中，点击  <strong>SDK Update Sites</strong>   添加你的xml的url。</p><p><em>我的操作：直接将zip下载下来解压，替换原来sdk对应的system-image，如<code>/sdk/system-images/android-23/default/x86</code></em></p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>如果没有修改代码，是不需要make update-api的，但是有代码修改后，make过程中，会提示你使用make update-api。我在make sdk的过程中，还提示要make update-support-api(不大记得是update-support-api还是support-update-api)，有需要系统会提示的，根据系统提示操作。</p><h1 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h1><ol><li>缺少kernel-ranchu，复制一个解决</li><li>开机黑屏，AVD Manager下，点击编辑，Emulated Performance - Graphics:改为SoftWare（尚不清楚其它解决方案）。关于这个黑屏，尝试好多次，启动后也有日志提示<code>EGL_emulation: tid 1232: eglCreateImageKHR(1206): error 0x300c E/GLConsumer: error creating EGLImage: 0x300c</code>，我一直以为是镜像的问题，试了几个版本，一直不行，最后几经搜索才找到改Graphics的方案，很是郁闷。</li></ol><h1 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h1><ol><li><p>error: ro.build.fingerprint cannot exceed 91 bytes:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: ro.build.fingerprint cannot exceed 91 bytes:</span><br></pre></td></tr></table></figure><p>编辑<code>build/tools/post_process_props.py</code>。更改行，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PROP_NAME_MAX = 31</span><br><span class="line"># PROP_VALUE_MAX = 91</span><br><span class="line">PROP_VALUE_MAX = 128</span><br></pre></td></tr></table></figure><p>编辑<code>bionic/libc/include/sys/system_properties.h</code>。更改行，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define PROP_NAME_MAX   32</span><br><span class="line">// #define PROP_VALUE_MAX  92</span><br><span class="line">#define PROP_VALUE_MAX  128</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make clobber</span><br><span class="line">make sdk sdk_repo</span><br></pre></td></tr></table></figure></li><li><p>jack服务错误，因为我是在6.0的源码上编译，还是使用的jack，报了两次服务没启动后，我就直接关了，修改为下面的SERVER&#x3D;false</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.jack</span><br><span class="line"></span><br><span class="line"># Server settings</span><br><span class="line">SERVER=false</span><br><span class="line">SERVER_PORT_SERVICE=8072</span><br><span class="line">SERVER_PORT_ADMIN=8073</span><br><span class="line">SERVER_COUNT=1</span><br><span class="line">SERVER_NB_COMPILE=4</span><br><span class="line">SERVER_TIMEOUT=60</span><br><span class="line">SERVER_LOG=$&#123;SERVER_LOG:=$SERVER_DIR/jack-$SERVER_PORT_SERVICE.log&#125;</span><br><span class="line">JACK_VM_COMMAND=$&#123;JACK_VM_COMMAND:=java&#125;</span><br><span class="line"># Internal, do not touch</span><br><span class="line">SETTING_VERSION=2</span><br></pre></td></tr></table></figure></li><li><p>make sdk_repo错误，生成的xml中值校验不通过。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Building SDK repository package system-images from android-sdk_eng.root_linux-x86.zip</span><br><span class="line">## Using xmlns:sdk=http://schemas.android.com/sdk/android/addon/2</span><br><span class="line">## Using root element sdk-addon</span><br><span class="line">## Add support/linux archive out/host/linux-x86/sdk/sdk_phone_x86//sdk-repo-linux-support-eng.root.zip</span><br><span class="line">## Validate XML against schema</span><br><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;sdk:sdk-addon xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:sdk=&quot;http://schemas.android.com/sdk/android/addon/2&quot;&gt;</span><br><span class="line">    &lt;sdk:extra&gt;</span><br><span class="line">        &lt;sdk:revision&gt;23.0.1&lt;/sdk:revision&gt;</span><br><span class="line">        &lt;sdk:vendor&gt;android&lt;/sdk:vendor&gt;</span><br><span class="line">        &lt;sdk:path&gt;support&lt;/sdk:path&gt;</span><br><span class="line">        &lt;sdk:archives&gt;</span><br><span class="line">            &lt;sdk:archive os=&quot;linux&quot;&gt;</span><br><span class="line">                &lt;sdk:size&gt;5504615&lt;/sdk:size&gt;</span><br><span class="line">                &lt;sdk:checksum type=&quot;sha1&quot;&gt;d7d984cfe9288f2cd32bb1601a138de32724faa2&lt;/sdk:checksum&gt;</span><br><span class="line">                &lt;sdk:url&gt;sdk-repo-linux-support-eng.root.zip&lt;/sdk:url&gt;</span><br><span class="line">            &lt;/sdk:archive&gt;</span><br><span class="line">        &lt;/sdk:archives&gt;</span><br><span class="line">    &lt;/sdk:extra&gt;</span><br><span class="line">&lt;/sdk:sdk-addon&gt;</span><br><span class="line">out/host/linux-x86/sdk/sdk_phone_x86/repo-extras.xml:6: element revision: Schemas validity error : Element &#x27;&#123;http://schemas.android.com/sdk/android/addon/2&#125;revision&#x27;: &#x27;23.0.1&#x27; is not a valid value of the atomic type &#x27;xs:positiveInteger&#x27;.</span><br><span class="line">out/host/linux-x86/sdk/sdk_phone_x86/repo-extras.xml fails to validate</span><br><span class="line">make: *** [out/host/linux-x86/sdk/sdk_phone_x86/repo-extras.xml] 错误 3</span><br><span class="line">make: *** 正在删除文件“out/host/linux-x86/sdk/sdk_phone_x86/repo-extras.xml”</span><br></pre></td></tr></table></figure><p>应该是xml中revision不是整数的问题。这个我就很郁闷，明明xml是自己生成的，偏偏校验不通过，make文件在<code>development/build/tools/mk_sdk_repo_xml.sh</code>里，xsd的文件在<code>prebuilts/devtools/repository</code>找到了，后续我也没改，直接把zip拿来用了。有兴趣的可以自己试试。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;想要编译一个自己的framework，用来在系统api中插入自己的代码，监听一下应用的行为，比如获取imei，获取网络。最直接的想法就是，修改安卓源码，直接编译出一个系统镜像，给模拟器使用。&lt;/p&gt;
&lt;p&gt;准备：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;因为之前编译过android.jar，所以源码环境还有，直接开工，或者看以前编译的文章有讲。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修改代码，比如找到TelephonyManager.java，在getDeviceId()中插入自己的代码。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="android" scheme="https://lefo.me/categories/android/"/>
    
    
    <category term="android" scheme="https://lefo.me/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>使用jenkins为android工程打包，支持多包名，改资源（优化方案）</title>
    <link href="https://lefo.me/2020/09/04/jenkins-android-3/"/>
    <id>https://lefo.me/2020/09/04/jenkins-android-3/</id>
    <published>2020-09-04T07:32:15.000Z</published>
    <updated>2025-10-24T04:45:37.608Z</updated>
    
    <content type="html"><![CDATA[<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>没有需求，自己看了一眼自己之前写的打包脚本，简直无法看下去。而且，产品经理的定制化需求越来越多，用shell脚本的可读性也越来越差，再加上里面一堆的sed命令，惨不忍睹。</p><p>改!!!</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>gradle其实支持自定义参数，关于自定义参数的介绍，参考官方文档：<a href="https://docs.gradle.org/current/userguide/build_environment.html%EF%BC%8C%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%80%E4%B8%8B%E7%94%A8%E5%88%B0%E7%9A%84%EF%BC%9A[Gradle">https://docs.gradle.org/current/userguide/build_environment.html，简单说一下用到的：[Gradle</a> properties](<a href="https://docs.gradle.org/current/userguide/build_environment.html#sec:gradle_configuration_properties)%EF%BC%9A">https://docs.gradle.org/current/userguide/build_environment.html#sec:gradle_configuration_properties)：</a></p><span id="more"></span><p>有两种方式传给gradle，一种是-P。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradlew clean -Pname=zhangsan</span><br></pre></td></tr></table></figure><p>另一种是gradle.properties，我们可以在build.gradle文件所在的目录下创建一个gradle.properties文件，写上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name=zhangsan</span><br></pre></td></tr></table></figure><p>通过这两种方式，在gradle脚本中就可以直接使用这个变量名。</p><p>比如如下的gradle配置，其中包含了int型，String型，boolean型，基本能满足需求了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">buildConfigField &quot;boolean&quot;, &quot;SHOW_INFO&quot;, &quot;$SHOW_INFO&quot;</span><br><span class="line">applicationId &quot;$PACKAGE_NAME&quot;</span><br><span class="line"></span><br><span class="line">versionCode Integer.valueOf(VERSION_CODE)</span><br><span class="line">versionName VERSION_NAME</span><br><span class="line"></span><br><span class="line">buildConfigField &quot;String&quot;, &quot;QQ_ID&quot;, &quot;\&quot;$qq_id\&quot;&quot;</span><br><span class="line">buildConfigField &quot;String&quot;, &quot;WX_RELEASE_ID&quot;, &quot;\&quot;$wx_id\&quot;&quot;</span><br></pre></td></tr></table></figure><p>对应的gradle.properties文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">VERSION_NAME=1.2</span><br><span class="line">VERSION_CODE=1110</span><br><span class="line">PACKAGE_NAME=me.lefo.jenkins</span><br><span class="line">SHOW_INFO=true</span><br><span class="line">qq_id=1001</span><br><span class="line">wx_id=1002</span><br></pre></td></tr></table></figure><h1 id="结合jenkins的参数化构建"><a href="#结合jenkins的参数化构建" class="headerlink" title="结合jenkins的参数化构建"></a>结合jenkins的参数化构建</h1><p>通常用jenkins在构建的时候，都会自定义一些参数，比如上文的VERSION_NAME，VERSION_CODE。当然，我们还有个奇葩的需求，改包名。</p><p>jenkins在搭建的时候，构建那一步一定要选<code>invoke gradle script</code>，点开下面的高级选项，勾选<code>Pass all job parameters as Project properties</code>，勾选这一项会将jenkins参数化构建时的参数写到gradle中，还会替换掉gradle.properties中的默认值。其实就是通过-P把参数传到了gradle，-P传入的优先级高于properties文件。</p><p><strong>一定要保证参数名和gradle.properties文件中的名字一样！！！</strong></p><p><strong>一定要保证参数名和gradle.properties文件中的名字一样！！！</strong></p><p><strong>一定要保证参数名和gradle.properties文件中的名字一样！！！</strong></p><h1 id="和包名绑定的配置"><a href="#和包名绑定的配置" class="headerlink" title="和包名绑定的配置"></a>和包名绑定的配置</h1><p>我们有个改包名的需求，有些配置化的值，是要跟着包名变动的，比如第三方平台的id。怎么办呢？这里的做法是，不同包名，建立不同的properties文件，执行时，使用cp -f命令，替换掉gradle.properties文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -f $PACKAGE_NAME.properties gradle.properties</span><br></pre></td></tr></table></figure><p>像一些构建时jenkins传入的参数，可以不在<code>包名.properties</code>里出现，但是，默认的gradle.properties文件必须有这些值，在as run的时候，还是得在gradle.properties中有个默认值的。但jenkins选了<code>invoke gradle script</code>，这些参数会通过-P传进去。</p><h1 id="manifest文件"><a href="#manifest文件" class="headerlink" title="manifest文件"></a>manifest文件</h1><p>manifest文件中，也会配置一些值，可以通过placeHolder传进去。比如channel</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">defaultConfig &#123;</span><br><span class="line">manifestPlaceholders = [label:&quot;@string/app_name&quot;,</span><br><span class="line">                                channel:&quot;$CHANNEL&quot;]</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在manifest中可以通过${channel}来使用，manifest中的authorities也可以通过这种方式来处理。</p><h1 id="改应用名"><a href="#改应用名" class="headerlink" title="改应用名"></a>改应用名</h1><p>我们有两个需求，一个是改用户界面显示的应用名，另一个是改APP内部显示的应用名，这两个有可能不一样。这里当然是通过sed改的，貌似也没有别的办法，上一段中的label也是用于这个功能的。我们的做法是把包含应用名关键字的strings.xml单独提取到一个value资源文件，然后通过sed统一修改。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i &#x27;s/默认应用名/&#x27;&quot;$APP_NAME&quot;&#x27;/g&#x27; myflavor/res/values/stringfile.xml</span><br></pre></td></tr></table></figure><h1 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h1><p>通过这波修改，之前的一坨sh文件中，就只剩下修改应用名的脚本了，其它的都通过gradle的环境变量来支持了。后续如果要加配置项，只需要在gradle.properties中加个默认项，如果是跟包名的，就放在包名.properties中，如果是jenkins配置的，就按对应的名称配在jenkins就OK。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h1&gt;&lt;p&gt;没有需求，自己看了一眼自己之前写的打包脚本，简直无法看下去。而且，产品经理的定制化需求越来越多，用shell脚本的可读性也越来越差，再加上里面一堆的sed命令，惨不忍睹。&lt;/p&gt;
&lt;p&gt;改!!!&lt;/p&gt;
&lt;h1 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;分析&lt;/h1&gt;&lt;p&gt;gradle其实支持自定义参数，关于自定义参数的介绍，参考官方文档：&lt;a href=&quot;https://docs.gradle.org/current/userguide/build_environment.html%EF%BC%8C%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%80%E4%B8%8B%E7%94%A8%E5%88%B0%E7%9A%84%EF%BC%9A[Gradle&quot;&gt;https://docs.gradle.org/current/userguide/build_environment.html，简单说一下用到的：[Gradle&lt;/a&gt; properties](&lt;a href=&quot;https://docs.gradle.org/current/userguide/build_environment.html#sec:gradle_configuration_properties)%EF%BC%9A&quot;&gt;https://docs.gradle.org/current/userguide/build_environment.html#sec:gradle_configuration_properties)：&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="android打包" scheme="https://lefo.me/categories/android%E6%89%93%E5%8C%85/"/>
    
    
    <category term="android" scheme="https://lefo.me/tags/android/"/>
    
    <category term="jenkins" scheme="https://lefo.me/tags/jenkins/"/>
    
  </entry>
  
  <entry>
    <title>android进程保活（掌握黑心科技）</title>
    <link href="https://lefo.me/2020/08/24/keep-alive/"/>
    <id>https://lefo.me/2020/08/24/keep-alive/</id>
    <published>2020-08-24T13:31:23.000Z</published>
    <updated>2025-10-24T04:45:37.608Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程保活"><a href="#进程保活" class="headerlink" title="进程保活"></a>进程保活</h1><p>android这个生态真的是不好，从一开始，大家就想方设法在后台常驻，为了让自己app不被杀，绞尽脑汁想各种存活办法。目前，之前用的大部分保活方案，在手机上几乎都是失效的，尤其是一些国内厂家机型，提供一键清理功能，把你正的运行的APP，杀的渣也不剩。所以，目前还能正常使用的方法就只有一种，那就是两个进程互相监听。</p><span id="more"></span><h1 id="技术原理"><a href="#技术原理" class="headerlink" title="技术原理"></a>技术原理</h1><ul><li>B发现A死了后，赶紧把A拉活，然后再把自己杀死，这样达到瞒天过海的效果。</li><li>进程A使用flock锁定一个文件，此时B进程再flock就会就会挂起，除非A进程主动释放或者结束，B进程才会继续，也就是所谓的监听</li><li>反射使用ActivityManagerService直接拉活组件</li></ul><h2 id="启动子进程"><a href="#启动子进程" class="headerlink" title="启动子进程"></a>启动子进程</h2><p>方案一：就是fork。fork会分离出一个子进程，在fork的地方开始执行接下来的工作，可以根据fork函数返回值来判断是主进程还是子进程。这里提到的另一个概念就是二次fork，关于二次fork和进程托孤，可以自行上网了解一下。</p><p>方案二：使用app_process命令启动一个java进程。<a href="https://blog.csdn.net/u010651541/article/details/53163542">https://blog.csdn.net/u010651541/article/details/53163542</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app_process &lt;dir&gt; &lt;class name&gt; &lt;parameters&gt; --application --nice-name=nice_name</span><br><span class="line">app_process -Djava.class.path=Helloworld.dex  dir classname</span><br></pre></td></tr></table></figure><p>当然了，要想启动java进程，classpath得设置，如执行export CLASSPATH，也可以使用-D来指定路径。如果有so要调用，还要将共享库加到环境变量中。export LD_LIBRARY_PATH 或者export _LD_LIBRARY_PATH</p><h2 id="两个进程如何互相监听"><a href="#两个进程如何互相监听" class="headerlink" title="两个进程如何互相监听"></a>两个进程如何互相监听</h2><p>这里有一个相当巧妙的方式，使用linux提供的函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int flock(int fd,LOCK_EX);</span><br></pre></td></tr></table></figure><p>具体用法请自行搜索，简单讲，A进程调用该函数后，此时B进程再调用，会造成B进程阻塞。而当A进程挂了后，B进程就会立马继续执行。</p><h2 id="如何拉活APP"><a href="#如何拉活APP" class="headerlink" title="如何拉活APP"></a>如何拉活APP</h2><p>要获取ams的IBinder，然后调用transact来启动组件。这里给大家提供源代码的路径，这里需要用反射。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mRemote = android.os.ServiceManager.getService(&quot;activity&quot;)</span><br><span class="line">mRemote.transact(code,data,null,FLAG_ONEWAY);</span><br></pre></td></tr></table></figure><p>这里有两部分需要处理，一个是code值，另一个就是data。关于code值，不同的安卓版本不一样，另外有的rom也会修改，翻看源码android.app.IActivityManager。关于data，也会根据不同的系统版本有不同的拼装方法。我这里以service为例。具体参数，也可以参考源码，下面的写法也是根据IActivityManager不同版本中的startService写的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mServiceData = Parcel.obtain();</span><br><span class="line">mServiceData.writeInterfaceToken(&quot;android.app.IActivityManager&quot;);</span><br><span class="line">mServiceData.writeStrongBinder(null);</span><br><span class="line">if (Build.VERSION.SDK_INT &gt;= 26) &#123;</span><br><span class="line">    mServiceData.writeInt(1);</span><br><span class="line">&#125;</span><br><span class="line">//这个是service的intent</span><br><span class="line">serviceIntent.writeToParcel(mServiceData, 0);</span><br><span class="line">mServiceData.writeString(null);</span><br><span class="line">if (Build.VERSION.SDK_INT &gt;= 26) &#123;</span><br><span class="line">    //fg service</span><br><span class="line">    mServiceData.writeInt(1);</span><br><span class="line">&#125;</span><br><span class="line">if (Build.VERSION.SDK_INT &gt;= 23) &#123;</span><br><span class="line">    String packageName = serviceIntent.getComponent().getPackageName();</span><br><span class="line">    mServiceData.writeString(packageName);</span><br><span class="line">&#125;</span><br><span class="line">mServiceData.writeInt(0);</span><br></pre></td></tr></table></figure><p>我声明一下，service保活在部分手机上可用。</p><h1 id="上代码"><a href="#上代码" class="headerlink" title="上代码"></a>上代码</h1><p><a href="https://github.com/xs93/free/tree/master/common/library-keepalivecore/src/main/java/com/keepalive/daemon/core">-&gt;具体保活代码看这里</a></p><p>20年最早做的时候是没找到这坨代码的，当时纯逆向+找资料总结的。前两天一搜，现在不知道谁上传了，就给看到的有缘人发出来，这套保活目前应该还能稍微撑一撑吧，就挺恶心的。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;进程保活&quot;&gt;&lt;a href=&quot;#进程保活&quot; class=&quot;headerlink&quot; title=&quot;进程保活&quot;&gt;&lt;/a&gt;进程保活&lt;/h1&gt;&lt;p&gt;android这个生态真的是不好，从一开始，大家就想方设法在后台常驻，为了让自己app不被杀，绞尽脑汁想各种存活办法。目前，之前用的大部分保活方案，在手机上几乎都是失效的，尤其是一些国内厂家机型，提供一键清理功能，把你正的运行的APP，杀的渣也不剩。所以，目前还能正常使用的方法就只有一种，那就是两个进程互相监听。&lt;/p&gt;</summary>
    
    
    
    <category term="android" scheme="https://lefo.me/categories/android/"/>
    
    
    <category term="android" scheme="https://lefo.me/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>python+selenium为你自动挂海淀驾校法陪课</title>
    <link href="https://lefo.me/2020/05/18/python-selenium/"/>
    <id>https://lefo.me/2020/05/18/python-selenium/</id>
    <published>2020-05-18T12:25:12.000Z</published>
    <updated>2025-10-24T04:45:37.608Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在北京摇号摇了18次了，下次开始就是四倍概率。然后，中签还是遥遥无期，隔壁坐的同事摇了两年就摇到了，万分羡慕。有时候晚上想去溜达一下，要去找gofun共享汽车还要走1公里多，还车还要走1公里。于是就有了想买一辆摩托车的想法。</p><p>要买车，肯定得有驾照，挑选完以后，报了海淀驾校，小区门口就有驾校的班车，关键是便宜，只要1000块。在我家那18线城市的小地方也得800多。于是报名，开始上法陪课。但法陪课每一章节必须自已手动点开始，很是麻烦，于是就想写个程序代替自己手点。</p><span id="more"></span><h2 id="手机端"><a href="#手机端" class="headerlink" title="手机端"></a>手机端</h2><p>法陪课可以在网页上上，也可以在APP上上，没自动播放，估计也是想让你好好学习，怕你偷懒吧。</p><p>因为我是做安卓的，起先打算拿在手机上搞，发现手机上是个自定义控件，基本不能用辅助功能（类似微信抢红包插件的技术）下手。唯一可用的就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb -s device_name shell input tap x y</span><br></pre></td></tr></table></figure><p>然后多久发一次命令又是个问题，于是就打算从网页上下手。</p><h2 id="网页端"><a href="#网页端" class="headerlink" title="网页端"></a>网页端</h2><p>网页上看，播放视频是一个flash，想用javascript也就没办法搞了，只得用selenium。</p><p>准备工作：</p><ul><li>Python：不解释</li><li>selenium: pip3 install selenium安装</li><li>Firefox：浏览器，本来我使用的是chrome，发现chrome对flash做了个优化，切后台后，flash不自动加载，换火狐就没问题了。</li><li>geckodriver:火狐浏览器的驱动，供selenium调用</li></ul><h1 id="放代码"><a href="#放代码" class="headerlink" title="放代码"></a>放代码</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line">from selenium.webdriver.common.action_chains import ActionChains</span><br><span class="line">from selenium.webdriver import FirefoxOptions</span><br><span class="line">from selenium.webdriver.support.wait import WebDriverWait</span><br><span class="line">import re</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def findTime(dr):</span><br><span class="line">    timeText = driver.find_element_by_class_name(&#x27;playing&#x27;).text</span><br><span class="line">    p1 = re.compile(r&#x27;[(](.*?)[)]&#x27;, re.S)</span><br><span class="line">    timeList = re.findall(p1, timeText)</span><br><span class="line">    if len(timeList) == 0:</span><br><span class="line">        return 0</span><br><span class="line">    else:</span><br><span class="line">        timearr = timeList[0].split(&#x27;:&#x27;)</span><br><span class="line">        return int(timearr[1]) * 60 + int(timearr[2])</span><br><span class="line"></span><br><span class="line">#flash的事件不能通过element触发 </span><br><span class="line">def click_locxy(dr, x, y, left_click=True):</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    dr:浏览器</span><br><span class="line">    x:页面x坐标</span><br><span class="line">    y:页面y坐标</span><br><span class="line">    left_click:True为鼠标左键点击，否则为右键点击</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    if left_click:</span><br><span class="line">        ActionChains(dr).move_by_offset(x, y).click().perform()</span><br><span class="line">    else:</span><br><span class="line">        ActionChains(dr).move_by_offset(x, y).context_click().perform()</span><br><span class="line">    ActionChains(dr).move_by_offset(-x, -y).perform()  # 将鼠标位置恢复到移动前</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">opts = FirefoxOptions()</span><br><span class="line">#opts.add_argument(&quot;--headless&quot;)</span><br><span class="line">option_profile = webdriver.FirefoxProfile()</span><br><span class="line">option_profile.set_preference(&quot;plugin.state.flash&quot;,2)</span><br><span class="line"></span><br><span class="line">path = &quot;/Users/lefo/Documents/dev/chrome/geckodriver&quot;# 注意这个路径需要时可执行路径（chmod 777 dir or 755 dir）</span><br><span class="line">driver = webdriver.Firefox(executable_path=path,options=opts)</span><br><span class="line">driver.get(&#x27;http://www.xuechebu.com/sign.html&#x27;)</span><br><span class="line">def playing():</span><br><span class="line">    playing = WebDriverWait(driver,60,1).until(lambda x:x.find_element_by_class_name(&#x27;playing&#x27;)) #等一分钟，直到获取到正在播放的控件</span><br><span class="line">    text = playing.text</span><br><span class="line">    print(text)</span><br><span class="line">    time.sleep(3) #等三秒，有时候文字可能加载慢</span><br><span class="line">    nextTime = findTime(dr=driver) #文字中提取括号内的时间</span><br><span class="line">    playing.click() #这里貌似无所谓，不点击也可以</span><br><span class="line">    print(str(nextTime))  #下一次执行的时间</span><br><span class="line">    time.sleep(10) #这个10s主要是为了flash允许有时间点</span><br><span class="line">    click_locxy(driver,750,540,left_click=True) #根据坐标点上去</span><br><span class="line">    time.sleep(nextTime + 5)  #这个5s和上面10s同样的道理</span><br><span class="line">count = 0</span><br><span class="line">while(count &lt;= 99):  #99这个数值具体自己设</span><br><span class="line">    playing()</span><br><span class="line">    count = count +1</span><br><span class="line"></span><br><span class="line">driver.quit()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>首先，获取正在播放的超链接，上面文字的格式：第x章节(00:02:30)表示2分30秒长，计算成秒，然后间隔这个时间值再去下一个循环。因为播放完成后会自动跳到下一个章节，只是不会开始播放而已，所以，我们要做的就是，间隔一段时间，点一下播放。</p><p>试过传入启动flash插件的参数，最后也失败了，所以启动后需要在一分钟内登录，然后去 附加组件 - 插件 将flash插件启用。再将页面上的flash点个允许。点完允许后，10s内会触发一次播放点击。如果你觉得1分钟的登录时间不够，那就改一下上面的时间，或者，加上登录的逻辑（其实我是有登录的，发文章的时候，删掉了）</p><p>如果你是其它挂课的网页，道理也是相同的，如果用JS可以实现还是用js吧。因为这个网页有flash的特殊性，才用的selenium，我对python和selenium都不熟，里面的函数几乎一个都不知道，只能边学边搜边写。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在北京摇号摇了18次了，下次开始就是四倍概率。然后，中签还是遥遥无期，隔壁坐的同事摇了两年就摇到了，万分羡慕。有时候晚上想去溜达一下，要去找gofun共享汽车还要走1公里多，还车还要走1公里。于是就有了想买一辆摩托车的想法。&lt;/p&gt;
&lt;p&gt;要买车，肯定得有驾照，挑选完以后，报了海淀驾校，小区门口就有驾校的班车，关键是便宜，只要1000块。在我家那18线城市的小地方也得800多。于是报名，开始上法陪课。但法陪课每一章节必须自已手动点开始，很是麻烦，于是就想写个程序代替自己手点。&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="https://lefo.me/categories/python/"/>
    
    
    <category term="python" scheme="https://lefo.me/tags/python/"/>
    
    <category term="selenium" scheme="https://lefo.me/tags/selenium/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV在Android NDK按需要的模块编译</title>
    <link href="https://lefo.me/2020/05/02/opencv-android/"/>
    <id>https://lefo.me/2020/05/02/opencv-android/</id>
    <published>2020-05-02T09:04:20.000Z</published>
    <updated>2025-10-24T04:45:37.608Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>公司要做一个和图片有关的功能，一说图片处理，大家首先想到的就是强大的OpenCV。OpenCV很强大，官方也提供了android专用的sdk，直接将so和jar放入项目中就能使用。尽管官方推荐的也是这种方式，但有一个问题是，OpenCV的库很大，有10MB，很多公司整个APK都没有10MB，如果要把真个库都放到项目中，那还是挺大的。所以，这里就需要我们自己编译。中间折腾了好久，写个文章记录一下。</p><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><h2 id="下载OpenCV"><a href="#下载OpenCV" class="headerlink" title="下载OpenCV"></a>下载OpenCV</h2><p>地址 <a href="https://opencv.org/releases/">https://opencv.org/releases/</a><br>选择Android平台的包</p><p>这里注意了，4.0的版本，要求api level是21以上，所以，如果你的APP是要在21以下使用，不要下载这个。</p><p>3.x的版本不清楚，但我试了OpenCV 2.x的版本是api level 8以上。2.x的版本，需要自行google，官方应该已经不提供了。</p><span id="more"></span><h2 id="配置gradle"><a href="#配置gradle" class="headerlink" title="配置gradle"></a>配置gradle</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">defaultConfig</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">ndkVersion &quot;16.1.4479499&quot;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        ndk &#123;</span><br><span class="line">            moduleName &quot;opencv-test&quot;</span><br><span class="line">            abiFilters &#x27;armeabi-v7a&#x27;,&#x27;x86&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    externalNativeBuild &#123;</span><br><span class="line">        cmake &#123;</span><br><span class="line">            path &quot;src/main/jni/CMakeLists.txt&quot;</span><br><span class="line">            version &quot;3.10.2&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，上面的ndkVersion可以不填，我这里是为了使用OpenCV 2.X版本，应该是需要r16的版本编译，因为使用当前最新的版本编译时，有个库找不到。</p><p>abi需要哪些请根据你自己的需要来填，有很多新入门的朋友抄的时候都不看内容，否则如果你其它so库在某平台缺失，可能会闪退。</p><p>CMakeLists.txt注意对应的目录是你JNI代码的目录</p><h2 id="CMakeLists-txt"><a href="#CMakeLists-txt" class="headerlink" title="CMakeLists.txt"></a>CMakeLists.txt</h2><p>在网上找的一个内容折腾了好久，终于算是弄明白了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#你的opencv解压目录</span><br><span class="line">set(OpenCV_DIR /OpenCV-android-sdk/sdk/native/jni)</span><br><span class="line">#这里也可以在后面跟具体模块OpenCV REQUIRED core imgproc 注意，写上并不代表会编译到包内</span><br><span class="line">FIND_PACKAGE(OpenCV REQUIRED)</span><br><span class="line">if(OpenCV_FOUND)</span><br><span class="line">    include_directories($&#123;OpenCV_INCLUDE_DIRS&#125;)</span><br><span class="line">    message(STATUS &quot;OpenCV library status:&quot;)</span><br><span class="line">    message(STATUS &quot;    version: $&#123;OpenCV_VERSION&#125;&quot;)</span><br><span class="line">    message(STATUS &quot;    libraries: $&#123;OpenCV_LIBS&#125;&quot;)</span><br><span class="line">    message(STATUS &quot;    include path: $&#123;OpenCV_INCLUDE_DIRS&#125;&quot;)</span><br><span class="line">else(OpenCV_FOUND)</span><br><span class="line">    message(FATAL_ERROR &quot;OpenCV library not found&quot;)</span><br><span class="line">endif(OpenCV_FOUND)</span><br><span class="line">#你的库</span><br><span class="line">add_library( native_test</span><br><span class="line">        SHARED</span><br><span class="line">        native.cpp)</span><br><span class="line"></span><br><span class="line">#include为头文件所在的目录hpp</span><br><span class="line">include_directories(/OpenCV-android-sdk/sdk/native/jni/include)</span><br><span class="line"></span><br><span class="line">#要链接的库</span><br><span class="line">target_link_libraries( native_test</span><br><span class="line">        $&#123;OpenCV_LIBS&#125;</span><br><span class="line">        log</span><br><span class="line">        jnigraphics)</span><br></pre></td></tr></table></figure><p>简单说一下上面的代码</p><ol><li>首先设置OpenCV_DIR环境变量，指定所在目录</li><li>找出配置的所包含的库，也就是OpenCV的模块</li><li>环境的打印，不用在意</li><li>add_library是你的库的配置，可以参考ndk的官方文档</li><li>include_directories是OpenCV的头文件目录</li><li>target_link_libraries这里要用到jnigraphics，还有日志打印的log（常用），注意看OpenCV_LIBS就是FIND_PACKAGE的内容，在3中会打印出来。</li></ol><p>搭建完后你就可以在代码中编写你的jni代码了，这样写出来的库，只会包含你用到的模块，比如你只用到了core和imgproc，那你的库打出来就只有1.8mb，这比OpenCV官方的要小了好多。</p><h1 id="附"><a href="#附" class="headerlink" title="附"></a>附</h1><p>写代码的时候，不要使用OpenCV的imread，这会导致有需要多导入模块，增加了包的体积。ndk中，有android&#x2F;bitmap.h，可以直接使用Bitmap对象来转Mat.</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;公司要做一个和图片有关的功能，一说图片处理，大家首先想到的就是强大的OpenCV。OpenCV很强大，官方也提供了android专用的sdk，直接将so和jar放入项目中就能使用。尽管官方推荐的也是这种方式，但有一个问题是，OpenCV的库很大，有10MB，很多公司整个APK都没有10MB，如果要把真个库都放到项目中，那还是挺大的。所以，这里就需要我们自己编译。中间折腾了好久，写个文章记录一下。&lt;/p&gt;
&lt;h1 id=&quot;准备&quot;&gt;&lt;a href=&quot;#准备&quot; class=&quot;headerlink&quot; title=&quot;准备&quot;&gt;&lt;/a&gt;准备&lt;/h1&gt;&lt;h2 id=&quot;下载OpenCV&quot;&gt;&lt;a href=&quot;#下载OpenCV&quot; class=&quot;headerlink&quot; title=&quot;下载OpenCV&quot;&gt;&lt;/a&gt;下载OpenCV&lt;/h2&gt;&lt;p&gt;地址 &lt;a href=&quot;https://opencv.org/releases/&quot;&gt;https://opencv.org/releases/&lt;/a&gt;&lt;br&gt;选择Android平台的包&lt;/p&gt;
&lt;p&gt;这里注意了，4.0的版本，要求api level是21以上，所以，如果你的APP是要在21以下使用，不要下载这个。&lt;/p&gt;
&lt;p&gt;3.x的版本不清楚，但我试了OpenCV 2.x的版本是api level 8以上。2.x的版本，需要自行google，官方应该已经不提供了。&lt;/p&gt;</summary>
    
    
    
    <category term="android" scheme="https://lefo.me/categories/android/"/>
    
    
    <category term="android" scheme="https://lefo.me/tags/android/"/>
    
    <category term="opencv" scheme="https://lefo.me/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>jenkins中实用的插件</title>
    <link href="https://lefo.me/2020/02/15/jenkins-plugins/"/>
    <id>https://lefo.me/2020/02/15/jenkins-plugins/</id>
    <published>2020-02-14T18:27:04.000Z</published>
    <updated>2025-10-24T04:45:37.608Z</updated>
    
    <content type="html"><![CDATA[<h1 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h1><p>最近疫情闹的有点凶，大家都是在家办公，刚好群里的一个妹子一边卖萌，一边问jenkins的搭建及使用，就用腾讯会议给辅导了一下。给她讲完后，翻了翻之前给公司搭建的环境，想记录一下之前使用过的Jenkins插件，供以后使用。</p><p>暂时就这些，有好用的插件会不定时更新。</p><h2 id="自带插件"><a href="#自带插件" class="headerlink" title="自带插件"></a>自带插件</h2><p>安装的时候，会提示你要选哪些插件，建议默认，像git svn以及gradle，这些插件会在默认插件列表里就存在。</p><h2 id="Git-Parameter"><a href="#Git-Parameter" class="headerlink" title="Git Parameter"></a>Git Parameter</h2><p>可用于把git的tag branch当作构建参数传进来，方便使用branch构建。</p><h2 id="SVN-Parameter"><a href="#SVN-Parameter" class="headerlink" title="SVN Parameter"></a>SVN Parameter</h2><p>同Git Parameter 一样是可以将tag branch当作构建参数传进来。</p><span id="more"></span><h2 id="Multiple-SCMs-plugin"><a href="#Multiple-SCMs-plugin" class="headerlink" title="Multiple SCMs plugin"></a>Multiple SCMs plugin</h2><p>可以加多个源码的插件，比如我们项目就是资源单独有一个SVN，所以要把代码checkout以后，再checkout资源。</p><h2 id="Environment-Injector-Plugin"><a href="#Environment-Injector-Plugin" class="headerlink" title="Environment Injector Plugin"></a>Environment Injector Plugin</h2><p>可以在构建时注入一些环境变量，这款插件有一个好处就是，它支持<code>Prepare an environment for the run</code>，可以在SCM以前注入变量，比如我们有个资源的svn地址，需要在构建时传进来然后checkout。为了更直观，参数默认值就留了空。有了这个插件，写了groovy脚本，手动将空值改成了默认资源地址，SCM那里直接使用参数名就OK了。</p><h2 id="Version-Number-Plug-In"><a href="#Version-Number-Plug-In" class="headerlink" title="Version Number Plug-In"></a>Version Number Plug-In</h2><p>用于自定义构建记录的名字的插件，使构建记录更直观，不再是#1 #2这种格式。</p><h2 id="Build-Keeper-Plugin"><a href="#Build-Keeper-Plugin" class="headerlink" title="Build Keeper Plugin"></a>Build Keeper Plugin</h2><p>可以按天数保留几天内的构建，没什么大用，如果硬盘紧张，推荐使用自带的Discard old builds</p><h2 id="Role-based-Authorization-Strategy"><a href="#Role-based-Authorization-Strategy" class="headerlink" title="Role-based Authorization Strategy"></a>Role-based Authorization Strategy</h2><p>按项目分权限，比如某个project不想让某人访问到，可以用这个插件。</p><h2 id="Copy-Artifact"><a href="#Copy-Artifact" class="headerlink" title="Copy Artifact"></a>Copy Artifact</h2><p>可以将上游JOB构建后生成的Artifact，复制到下游的JOB来使用，比如上游的JOB生成的apk。</p><h2 id="Validating-String-Parameter-Plugin"><a href="#Validating-String-Parameter-Plugin" class="headerlink" title="Validating String Parameter Plugin"></a>Validating String Parameter Plugin</h2><p>用于参数校验的插件，像产品打包的时候versionCode总是喜欢空着，说多少次都不长心，还让开发看一下为什么打包失败，最后就使用了这个插件，输入时校验。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;记录&quot;&gt;&lt;a href=&quot;#记录&quot; class=&quot;headerlink&quot; title=&quot;记录&quot;&gt;&lt;/a&gt;记录&lt;/h1&gt;&lt;p&gt;最近疫情闹的有点凶，大家都是在家办公，刚好群里的一个妹子一边卖萌，一边问jenkins的搭建及使用，就用腾讯会议给辅导了一下。给她讲完后，翻了翻之前给公司搭建的环境，想记录一下之前使用过的Jenkins插件，供以后使用。&lt;/p&gt;
&lt;p&gt;暂时就这些，有好用的插件会不定时更新。&lt;/p&gt;
&lt;h2 id=&quot;自带插件&quot;&gt;&lt;a href=&quot;#自带插件&quot; class=&quot;headerlink&quot; title=&quot;自带插件&quot;&gt;&lt;/a&gt;自带插件&lt;/h2&gt;&lt;p&gt;安装的时候，会提示你要选哪些插件，建议默认，像git svn以及gradle，这些插件会在默认插件列表里就存在。&lt;/p&gt;
&lt;h2 id=&quot;Git-Parameter&quot;&gt;&lt;a href=&quot;#Git-Parameter&quot; class=&quot;headerlink&quot; title=&quot;Git Parameter&quot;&gt;&lt;/a&gt;Git Parameter&lt;/h2&gt;&lt;p&gt;可用于把git的tag branch当作构建参数传进来，方便使用branch构建。&lt;/p&gt;
&lt;h2 id=&quot;SVN-Parameter&quot;&gt;&lt;a href=&quot;#SVN-Parameter&quot; class=&quot;headerlink&quot; title=&quot;SVN Parameter&quot;&gt;&lt;/a&gt;SVN Parameter&lt;/h2&gt;&lt;p&gt;同Git Parameter 一样是可以将tag branch当作构建参数传进来。&lt;/p&gt;</summary>
    
    
    
    <category term="jenkins" scheme="https://lefo.me/categories/jenkins/"/>
    
    
    <category term="jenkins" scheme="https://lefo.me/tags/jenkins/"/>
    
  </entry>
  
  <entry>
    <title>Git中rebase的常规使用</title>
    <link href="https://lefo.me/2020/01/09/git-rebase/"/>
    <id>https://lefo.me/2020/01/09/git-rebase/</id>
    <published>2020-01-09T12:21:39.000Z</published>
    <updated>2025-10-24T04:45:37.608Z</updated>
    
    <content type="html"><![CDATA[<h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1><p>公司从svn版本管理切换成了git，Android Studio（Intellij IDEA）也可以较好的支持git，相当方便。git有一个特别强大的命令，那就是rebase，这篇blog就记一下git rebase的一些使用。</p><h2 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h2><p><a href="https://git-scm.com/docs/git-rebase">https://git-scm.com/docs/git-rebase</a></p><h2 id="一个不错的操作模拟"><a href="#一个不错的操作模拟" class="headerlink" title="一个不错的操作模拟"></a>一个不错的操作模拟</h2><p><a href="https://learngitbranching.js.org/">https://learngitbranching.js.org/</a></p><span id="more"></span><h1 id="git-rebase的常用操作"><a href="#git-rebase的常用操作" class="headerlink" title="git rebase的常用操作"></a>git rebase的常用操作</h1><p>本文不另辟捷径，官方文档讲的很详细，就挑几个官方的例子翻译一下。</p><h2 id="案例1-："><a href="#案例1-：" class="headerlink" title="案例1 ："></a>案例1 ：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      A---B---C topic</span><br><span class="line">     /</span><br><span class="line">D---E---F---G master</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rebase master</span><br><span class="line">git rebase master topic</span><br></pre></td></tr></table></figure><p>上面两条命令，执行其中的一条就可以，执行以后。其实就是git rebase upstream branch</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">              A&#x27;--B&#x27;--C&#x27; topic</span><br><span class="line">             /</span><br><span class="line">D---E---F---G master</span><br></pre></td></tr></table></figure><h2 id="案例2：–onto的使用"><a href="#案例2：–onto的使用" class="headerlink" title="案例2：–onto的使用"></a>案例2：–onto的使用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rebase [-i | --interactive] [&lt;options&gt;] [--exec &lt;cmd&gt;]</span><br><span class="line">[--onto &lt;newbase&gt; | --keep-base] [&lt;upstream&gt; [&lt;branch&gt;]]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">o---o---o---o---o  master</span><br><span class="line">     \</span><br><span class="line">      o---o---o---o---o  next</span><br><span class="line">                       \</span><br><span class="line">                        o---o---o  topic</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase --onto master next topic</span><br></pre></td></tr></table></figure><p>执行的结果为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">o---o---o---o---o  master</span><br><span class="line">    |            \</span><br><span class="line">    |             o&#x27;--o&#x27;--o&#x27;  topic</span><br><span class="line">     \</span><br><span class="line">      o---o---o---o---o  next</span><br></pre></td></tr></table></figure><p>这里–onto的后面有三个参数（其实属于–onto的就一个）</p><ol><li>参数1：要跟随在哪个commit，可以是分支名，也可以是commit的 Revision Number</li><li>参数2：after-this-commit 意思是，从这个commit之后的开始算，这个commit是不算的</li><li>参数3：要操作的最后一个commit，这个本身是要算进去的。</li></ol><h2 id="复制一段commits到另一个分支（as应该不支持）"><a href="#复制一段commits到另一个分支（as应该不支持）" class="headerlink" title="复制一段commits到另一个分支（as应该不支持）"></a>复制一段commits到另一个分支（as应该不支持）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A---B---C---D---E  master</span><br><span class="line">     \</span><br><span class="line">      F---G---H---I---J---K---L---M  topic</span><br></pre></td></tr></table></figure><p>比如想把K L M的提交copy到master上，那么可以使用命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git rebase --onto E J M</span><br><span class="line">git rebase HEAD master</span><br></pre></td></tr></table></figure><p>结果为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A---B---C---D---E---K‘---L’---M‘  master</span><br><span class="line">     \</span><br><span class="line">      F---G---H---I---J---K---L---M  topic</span><br></pre></td></tr></table></figure><p>注意这里一定要<code>git rebase HEAD master</code>，因为执行了第二条rebase后，只是复制了一份commit过去，需要处理一下master和HEAD。</p><h2 id="案例3：合并多条commit为一条"><a href="#案例3：合并多条commit为一条" class="headerlink" title="案例3：合并多条commit为一条"></a>案例3：合并多条commit为一条</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i &lt;after-this-commit&gt;</span><br></pre></td></tr></table></figure><p>执行上述命令后，会让你配置每一项的处理方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pick ：不做任何修改；</span><br><span class="line">reword：只修改提交注释信息；</span><br><span class="line">edit：修改提交的文件，做增补提交；</span><br><span class="line">squash：将该条提交合并到上一条提交，提交注释也一并合并；</span><br><span class="line">fixup：将该条提交合并到上一条提交，废弃该条提交的注释；</span><br></pre></td></tr></table></figure><h1 id="关于Android-Studio"><a href="#关于Android-Studio" class="headerlink" title="关于Android Studio"></a>关于Android Studio</h1><p>AS内置的插件可以满足大部分功能，按command + 9可以唤出来log tab<br>附上操作指南：<br><a href="https://www.jetbrains.com/help/idea/edit-project-history.html">https://www.jetbrains.com/help/idea/edit-project-history.html</a></p><p>我试了试，最终在as里没有找到 –onto 复制一段commits的方式，因为第三个参数必须得选branch，在stackoverflow里，找到一处资料。对比可以看到，如果和上述一段commits，是缺少参数的，所以这里得用命令行了。实际中，也劝大家尽量不要用这种方式。</p><blockquote><p>The rebase dialog in IntelliJ 12.1 uses the most general version of the rebase command:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase [-i] [--onto newbase] [upstream] [branch]</span><br></pre></td></tr></table></figure><p>where IntelliJ’s “Onto” field corresponds to <code>--onto newbase</code>, IntelliJ’s “From” field corresponds to “upstream” and IntelliJ’s “Branch” field corresponds to “branch”.</p><p>In above git rebase command all parameters are optional, while in IntelliJ they are not. This means that you have to take your git rebase command and express it using the general form shown above.</p><p>Note that what you actually do with the arguments of the rebase command is define a range of commits that will be replayed in a new target location. Generally, the range is <code>upstream..branch</code>. If you are not familiar with commit ranges you should read up on them.</p><p>Let’s look at your example and assume that you are on branch “branch”:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD~4</span><br></pre></td></tr></table></figure><p>Let’s first figure out which is the range. Since you have only one argument, <code>HEAD~4</code>, this corresponds to upstream, i.e. the range is <code>HEAD~4..branch</code> or in other words <code>HEAD~4..HEAD</code> on branch “branch”. The question is now which is your –onto target. If you avoid <code>--onto</code>, then git assumes that your upstream is also your <code>--onto</code>.</p><p>This yields:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i --onto HEAD~4 HEAD~4 branch</span><br></pre></td></tr></table></figure><p>and now you can fill in IntelliJ’s rebase dialog using</p><ul><li>Onto: <code>HEAD~4</code></li><li>From: <code>HEAD~4</code></li><li>Branch: <code>branch</code></li></ul><p>IntelliJ actually forces you to think first and identify your range and target, which looks more complicated, but which prevents you from doing a rebase without understanding what the result will be.</p><p><a href="https://stackoverflow.com/questions/14608812/how-to-do-interactive-rebase-with-intellij-idea">https://stackoverflow.com/questions/14608812/how-to-do-interactive-rebase-with-intellij-idea</a></p></blockquote><p>注意AS中，也可以勾选-i参数</p><p>如果是只有一条提交记录，通常用cherry-pick很方便，rebase可以用来处理多条commits的时候。当然，你也可以把commit先执行squash，再执行cherry-pick。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;git&quot;&gt;&lt;a href=&quot;#git&quot; class=&quot;headerlink&quot; title=&quot;git&quot;&gt;&lt;/a&gt;git&lt;/h1&gt;&lt;p&gt;公司从svn版本管理切换成了git，Android Studio（Intellij IDEA）也可以较好的支持git，相当方便。git有一个特别强大的命令，那就是rebase，这篇blog就记一下git rebase的一些使用。&lt;/p&gt;
&lt;h2 id=&quot;官方文档&quot;&gt;&lt;a href=&quot;#官方文档&quot; class=&quot;headerlink&quot; title=&quot;官方文档&quot;&gt;&lt;/a&gt;官方文档&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://git-scm.com/docs/git-rebase&quot;&gt;https://git-scm.com/docs/git-rebase&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;一个不错的操作模拟&quot;&gt;&lt;a href=&quot;#一个不错的操作模拟&quot; class=&quot;headerlink&quot; title=&quot;一个不错的操作模拟&quot;&gt;&lt;/a&gt;一个不错的操作模拟&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://learngitbranching.js.org/&quot;&gt;https://learngitbranching.js.org/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="git" scheme="https://lefo.me/categories/git/"/>
    
    
    <category term="git" scheme="https://lefo.me/tags/git/"/>
    
  </entry>
  
</feed>
